#include "interp.h"
#include "input.h"
#include "pdb.h"
#include "dcd.h"
#include "util.h"
#include "mutil.h"
#include <math.h>
#include "M_matrix.h"
#include "alignSet.h"
#include "GJK.h"
//#define DEBUG_PRINT
static double solvation_cutoff = 2.5;
static double solvation_cutoff_MARTINI = 5.0;
static double ion_cutoff = 5.0;
static double PP = 15.0;
//static double PP = 25.0;
static int debug_on = 0;
static int activate_martini = 0;
static int **global_cycles = NULL;
static int *global_cycle_len = NULL;
static int global_ncycles = 0;
static int global_nspace = 0;

static int *global_bonds = NULL;
static int *global_nbonds = NULL;
static int *global_bond_offsets = 0;
static int global_bonds_tot = 0;
static int global_bond_space = 0;
static int global_atom_space = 0;


const char *charmm_header =
"* GENERATED BY CHARMM-GUI (http://www.charmm-gui.org)\n"
"* ASSEMBLY step.\n"
"*\n"
"\n"
"DIMENS CHSIZE 6000000 MAXRES 6000000\n"
"\n"
"! Read topology and parameter files\n"
"stream toppar.str\n"
"\n";

const char *charmm_footer = 
"!\n"
"! Write PSF, coordinates, and information of the assembled system\n"
"!\n"
"\n"
"open write unit 10 card name system.psf\n"
"write psf  unit 10 card\n"
"\n"
"open write unit 10 card name system.crd\n"
"write coor  unit 10 card\n"
"\n"
"open write unit 10 card name system.pdb\n"
"write coor  pdb unit 10\n"
"\n"
"stop\n";

double mod_exp( double val );

struct crd_psf_pair
{
	char CRDfileName[256];
	char PSFfileName[256];
};
void EndSegment( FILE *charmmFile, char *cur_filename, char *cur_segment, char *cur_segname,	crd_psf_pair **pairs, int *seg_cntr, int *npairs, int *npair_space, int x_leaflet,
	int *cur_size, int *cur_natoms, int *cur_atom, int *cur_res, int *switched, int gm1_switch );

struct caa_box
{
	int np;
	int npSpace;
	int *plist;
};

int TestAdd( surface *theSurface, int l, int *lipid_start, int *lipid_stop, struct atom_rec *at, 
	double *shift, double *upper_cen, double *add_to,
	double alpha,
	double main_u_cen,
	double main_v_cen,
	double *use_r, double *source_r,
	double spot_u, double spot_v,
	int fout,
	double *rsurf,
	int leaflet,
	double strain,
	double *dx_uv,
	double *dy_uv,	
	double w_use,
	double w_rim,
	double *rimp,
	double *rimn,
	int x_leaflet,
	double *total_lipid_charge,
	int *cur_atom,
	int *cur_natoms,
	double **placed_atoms,
	int *nplaced,
	int *nplacedSpace,
	char *cur_segname,
	char **cur_segment,
	int *cur_size,
	int *cur_space,
	int *cur_res,
	caa_box *theBoxes, int nx, int ny, int nz,

	int **local_cycle,
	int *local_cycle_len,
	int ncycle,
	
	int *local_bonds,
	int *local_nbonds,
	int *local_bond_offset,
	
	FILE *doubleBondIndexes
	);

int TestAddRim( surface *theSurface, int l, int *lipid_start, int *lipid_stop, struct atom_rec *at, 
	double dx, double dy,
	double *lipid_xyz,
	double *shift, double *upper_cen, double *rim_center,
	double alpha,
	double *use_r,
	double *rsurf,
	int leaflet,
	int x_leaflet,
	double *total_lipid_charge,
	int *cur_atom,
	int *cur_natoms,
	double **placed_atoms,
	int *nplaced,
	int *nplacedSpace,
	char *cur_segname,
	char **cur_segment,
	int *cur_size,
	int *cur_space,
	int *cur_res,
	caa_box *theBoxes, int nx, int ny, int nz,
	
	int **local_cycle,
	int *local_cycle_len,
	int ncycle,
	
	int *local_bonds,
	int *local_nbonds,
	int *local_bond_offsets
	);
	
void boxit( double *r_in, int index, caa_box *theBoxes, double PBC_vec[3][3], int nx, int ny, int nz ); 

void surface::createAllAtom( parameterBlock *block )
{
	double *rsurf = (double *)malloc( sizeof(double) * 3 * (1 + nv) );

	PP = block->neutral_surface;
	
	get(rsurf);
	rsurf[3*nv+0] = 1.0;
	rsurf[3*nv+1] = 1.0;
	rsurf[3*nv+2] = 1.0;

	// write the mesh we are building into all-atom. Remove this later but I need it to debug.

	FILE *tpsf = NULL;
	char fname[256];
	sprintf(fname, "%s_create.psf", block->jobName );
	tpsf = fopen(fname,"w");
	sprintf(fname, "%s_create.xyz", block->jobName );
	writeLimitingSurfacePSF(tpsf);
	fclose(tpsf);
	FILE *tFile = fopen(fname,"w");
	writeLimitingSurface(tFile);
	fclose(tFile);

	// outputs in CHARMM coordinate format

	// breakdown system into as many approximately square patches as possible, with the correct areas?

	char fileName[256];
	sprintf(fileName, "create_%s_charmm.inp", block->jobName );
	FILE *charmmFile = fopen(fileName,"w");

	if( !charmmFile )
	{
		printf("Couldn't open file \"%s\" for writing.\n", fileName );
		exit(1);
	}
	
	fprintf(charmmFile, "%s", charmm_header );

	struct atom_rec *master_at[3] = {NULL,NULL,NULL};
	int nat[3] = {0,0,0};
		
	int *master_lipid_start[3] = {NULL,NULL,NULL};
	// the index where a lipid's atoms stop
	int *master_lipid_stop[3] = {NULL,NULL,NULL};
	// the coordinates of that lipid.
	double *master_lipid_xyz[3] = {NULL,NULL,NULL};
	int *master_leaflet[3] = {NULL,NULL,NULL};
	int master_nlipids[3] = {0,0,0};
	double master_Lx[3]={0,0,0},master_Ly[3]={0,0,0},master_Lz[3]={0,0,0},alpha,beta,gamma;
	int **master_cycles[3] = {NULL,NULL,NULL};
	int *master_cycle_lengths[3] = {NULL,NULL,NULL};
	int master_ncycles[3] = {0,0,0};

	int *master_bonds[3] = { NULL, NULL, NULL };
	int *master_nbonds[3] = { NULL, NULL, NULL };
	int *master_bond_offsets[3] = { NULL, NULL, NULL };

	// the code for inner leaflet (x_leaflet == 0 )	
	int inner_leaflet = 0;

	if( !block->innerPatchPDB && !block->outerPatchPDB)
	{
		printf("Structure building requires a valid pdb file, \"patchPDB\", \"innerPatchPDB\", or \"outerPatchPDB\"\n");
		exit(1); 
	}

	int do_leaflet[3] = { 0,0 };
	
	struct atom_rec *protein;
	int nprotein=0;
	int proteinIsCRD = 0;
	int loadProtein = 0;

	char *doubleBondFile = (char *)malloc( sizeof(char) * (strlen(block->jobName) + 1 + strlen(".indx") ) );
	sprintf(doubleBondFile, "%s.indx", block->jobName );
	FILE *doubleBondIndexes = (FILE *)fopen( doubleBondFile, "w" );
	if( !doubleBondIndexes )
	{
		printf("Couldn't open double-bond index file for writing ('%s').\n", doubleBondFile);
		exit(1);
	}
	free(doubleBondFile);

	char proteinCRDName[256];
	char proteinPSFName[256];

	double total_charge       = 0;
	double total_protein_charge       = 0;
	double total_lipid_charge[3] = {0,0};

	if( block->addProteinPDB )
	{
		FILE *pdbFile = fopen(block->addProteinPDB, "r" );
		strcpy( proteinCRDName, block->addProteinPDB );		

		if( !pdbFile )
		{
			printf("Couldn't open file \"%s\"\n", block->addProteinPDB );
			exit(1);
		}
	
		if( block->addProteinPSF )
		{
			FILE *psfFile = fopen(block->addProteinPSF,"r");
			
			if( !psfFile )
			{
				printf("Couldn't open file \"%s\"\n", block->addProteinPSF );
				exit(1);
			}
	
			loadPSF( psfFile );
			strcpy( proteinPSFName, block->addProteinPSF );		
		}
		else
		{
			printf("Loading a protein requires a PSF for the protein.\n");
			exit(1);
//			loadPSFfromPDB( pdbFile );
		}	
		nprotein = curNAtoms();
			
		protein = (struct atom_rec *)malloc( sizeof(struct atom_rec ) * nprotein );
		rewind(pdbFile);
		if( !strcasecmp( block->addProteinPDB+strlen(block->addProteinPDB)-3,"crd" ) )
		{
			proteinIsCRD = 1;
			loadCRD( pdbFile, protein);
		}
		else
			loadPDB( pdbFile, protein);
		loadProtein = 1;
		fclose(pdbFile);

		for( int p = 0; p < nprotein; p++ )
			total_protein_charge += protein[p].charge;
	
		printf("Total protein charge: %.14le\n", total_protein_charge );
	}


	struct atom_rec *solvate;
	int nsolvate=0;
	double solvate_PBC[3] = { -1,-1,-1};

	if( block->solvatePDB )
	{
		FILE *pdbFile = fopen(block->solvatePDB, "r" );

		if( !pdbFile )
		{
			printf("Couldn't open file \"%s\"\n", block->solvatePDB );
			exit(1);
		}
	
		if( block->solvatePSF )
		{
			FILE *psfFile = fopen(block->solvatePSF,"r");
			
			if( !psfFile )
			{
				printf("Couldn't open file \"%s\"\n", block->solvatePSF );
				exit(1);
			}
	
			loadPSF( psfFile );
		
		}
		else
			loadPSFfromPDB( pdbFile );
			
		nsolvate= curNAtoms();
			
		solvate = (struct atom_rec *)malloc( sizeof(struct atom_rec ) * nsolvate );
		rewind(pdbFile);
		loadPDB( pdbFile, solvate );
		
		if( !strcasecmp( solvate[0].atname, "W") )	
			activate_martini = 1;
		if( !strcasecmp( solvate[0].atname, "PW") )	
			activate_martini = 1;

		double alpha,beta,gamma;
		if( PBCD( solvate_PBC+0,solvate_PBC+1,solvate_PBC+2,&alpha,&beta,&gamma) )
		{
			printf("Couldn't read CRYST1 record from solvation PDB.\n");
			exit(1);
		}
	}

	if( activate_martini )
	{
		printf("Using MARTINI based solute/solvent cutoff.\n");
		solvation_cutoff = solvation_cutoff_MARTINI;
	}

	solvation_cutoff *= block->scale_solvent_approach;

	for( int pass = 0; pass < 3; pass++ )
	{
		FILE *pdbFile;	
				
		int **basis=NULL;
		int *basis_length=NULL;
		int nbasis=0;
		int loaded_psf = 0;
	
		if( pass == 0 && block->innerPatchPDB )
		{
			pdbFile = fopen(block->innerPatchPDB, "r" );
			do_leaflet[0] = 1;

			if( !pdbFile )
			{
				printf("Couldn't open file \"%s\"\n", block->innerPatchPDB );
				exit(1);
			}

			if( block->innerPatchPSF )
			{
				FILE *psfFile = fopen(block->innerPatchPSF,"r");
			
				if( !psfFile )
				{
					printf("Couldn't open file \"%s\"\n", block->innerPatchPSF );
					exit(1);
				}
	
				loadPSF( psfFile );
		
				loaded_psf = 1;	
				
			}
			else
				loadPSFfromPDB( pdbFile );
		}
		else if( pass == 1 && block->outerPatchPDB ) 
		{
			do_leaflet[1] = 1;
			pdbFile = fopen(block->outerPatchPDB, "r" );
			if( !pdbFile )
			{
				printf("Couldn't open file \"%s\"\n", block->outerPatchPDB );
				exit(1);
			}
			if( block->outerPatchPSF )
			{
				FILE *psfFile = fopen(block->outerPatchPSF,"r");
	
				if( !psfFile )
				{
					printf("Couldn't open file \"%s\"\n", block->outerPatchPSF );
					exit(1);
				}
	
				loaded_psf = 1;	
				loadPSF( psfFile );
			}
			else
				loadPSFfromPDB( pdbFile );
		}
		else if( pass == 2 && block->altPatchPDB )
		{
			pdbFile = fopen(block->altPatchPDB, "r" );
			do_leaflet[2] = 1;

			if( !pdbFile )
			{
				printf("Couldn't open file \"%s\"\n", block->altPatchPDB );
				exit(1);
			}

			if( block->altPatchPSF )
			{
				FILE *psfFile = fopen(block->altPatchPSF,"r");
			
				if( !psfFile )
				{
					printf("Couldn't open file \"%s\"\n", block->altPatchPSF );
					exit(1);
				}
	
				loaded_psf = 1;	
				loadPSF( psfFile );
			}
			else
				loadPSFfromPDB( pdbFile );
		}
		else if( block->patchPDB )
		{
			do_leaflet[pass] = -1;
			pdbFile = fopen(block->patchPDB,"r");
			if( !pdbFile )
			{
				printf("Couldn't open file \"%s\"\n", block->patchPDB );
				exit(1);
			}
			if( block->patchPSF )
			{
				FILE *psfFile = fopen(block->patchPSF,"r");

				if( !psfFile )
				{
					printf("Couldn't open file \"%s\"\n", block->patchPDB );
					exit(1);
				}

				loaded_psf = 1;	
				loadPSF( psfFile );
			}
			else
				loadPSFfromPDB( pdbFile );
		}
		else
			continue;
		master_at[pass] = (struct atom_rec *)malloc( sizeof(struct atom_rec ) * curNAtoms() );
		nat[pass] = curNAtoms();

		struct atom_rec *at = master_at[pass];


		rewind(pdbFile);
		loadPDB( pdbFile, at );	
	
		fclose(pdbFile);
		
		if( PBCD( master_Lx+pass,master_Ly+pass,master_Lz+pass,&alpha,&beta,&gamma) )
		{
			printf("Couldn't read CRYST1 record from PDB.\n");
			exit(1);
		}
		
		double Lx = master_Lx[pass];
		double Ly = master_Ly[pass];
		double Lz = master_Lz[pass];

		// the index where a lipid's atoms start
		master_lipid_start[pass] = (int *)malloc( sizeof(int) * curNAtoms() );
		// the index where a lipid's atoms stop
		master_lipid_stop[pass]  = (int *)malloc( sizeof(int) * curNAtoms() );
		// the coordinates of that lipid.
		master_lipid_xyz[pass]       = (double *)malloc( sizeof(double) * 3 * curNAtoms() );
		master_leaflet[pass]            = (int *)malloc( sizeof(int) * curNAtoms() );
		master_nlipids[pass] = 0;
		
		int *bond_offsets = NULL;
		int *nbonds = NULL;
		int *bond_list = NULL;
		
		if( loaded_psf ) // get rings of the molecules for penetration search.
		{
			fetchCycleBasis( &basis, &basis_length, &nbasis );

			int nb = getNBonds();
			int *bonds = (int *)malloc( sizeof(int) * nb * 2 );
			getBonds(bonds);

			bond_offsets = (int *)malloc( sizeof(int) * nat[pass] );
			nbonds = (int *)malloc( sizeof(int) * nat[pass] );
			memset( nbonds, 0, sizeof(int) * nat[pass] );
			int off = 0;		

			for( int b = 0; b < nb; b++ )
			{
				nbonds[bonds[2*b+0]] += 1;	
				nbonds[bonds[2*b+1]] += 1;	
			}

			for( int a = 0; a < curNAtoms(); a++ )
			{
				bond_offsets[a]=off;
				off += nbonds[a];
			}

			bond_list = (int *)malloc( sizeof(int) * off );
			memset( nbonds, 0, sizeof(int) * nat[pass] );

			for( int b = 0; b < nb; b++ )
			{
				int a1 = bonds[2*b+0];
				int a2 = bonds[2*b+1];
				bond_list[bond_offsets[a1]+nbonds[a1]] = a2;
				nbonds[a1] += 1;	
				bond_list[bond_offsets[a2]+nbonds[a2]] = a1;
				nbonds[a2] += 1;	
			}						
		}

		master_cycles[pass] = basis;
		master_cycle_lengths[pass] = basis_length;
		master_ncycles[pass] = nbasis;
	
		master_bonds[pass] = bond_list;
		master_nbonds[pass] = nbonds;
		master_bond_offsets[pass] = bond_offsets;

		int *lipid_start = master_lipid_start[pass];
		int *lipid_stop = master_lipid_stop[pass];
		double *lipid_xyz = master_lipid_xyz[pass];
		int *leaflet = master_leaflet[pass];
		char p_segid[256];
		int pres = -1;
		int seg_continuity_mode = 0;
		p_segid[0] = '\0';
		// fill the index
	
		int nlipids=-1;
		for( int a = 0; a < curNAtoms(); a++ )
		{
			if( !strcasecmp( at[a].resname, "TIP3") ) continue;
			if( !strcasecmp( at[a].resname, "W") ) continue;
			if( !strcasecmp( at[a].resname, "SOD") ) continue;
			if( !strcasecmp( at[a].resname, "POT") ) continue;
			if( !strcasecmp( at[a].resname, "CLA") ) continue;
	
			if( !strncasecmp( at[a].segid, "GLPA", 4) ||
		  	    !strncasecmp( at[a].segid, "PRO", 3) )
				seg_continuity_mode = 1;
			else
				seg_continuity_mode = 0;
	
			if( (!seg_continuity_mode && (at[a].res != pres)) || strcasecmp( at[a].segid, p_segid) )
			{  
				nlipids++;
				// a new residue. is it a lipid, or protein?
				// for now, assume everything is going in, except water.
				
				lipid_start[nlipids] = a;
				lipid_stop[nlipids] = a;
					
			}
			else
			{
				lipid_stop[nlipids] = a;
			}
			strcpy( p_segid, at[a].segid ); 
			pres = at[a].res;
		}
	
		// the last "lipid" doesn't get incremented.
		nlipids++;
		
		if( block->create_flip )
		{
			for( int a = 0; a < curNAtoms(); a++ )
			{
				at[a].x = -at[a].x;
				at[a].z = -at[a].z;
			}
		}
	
		// get the bilayer center.
	
	#define N_BINS_MOLDIST 100
	
	        double best_chi2 = 1e10;
		double wrapto = 0;
	 
	        double moldist[N_BINS_MOLDIST];
	        memset( moldist, 0, sizeof(double) * N_BINS_MOLDIST );
	
	
		for( int l = 0; l < nlipids; l++ )
		{
			for( int p = lipid_start[l]; p <= lipid_stop[l]; p++ )
			{
	                      double tz = at[p].z;
	
	                      while( tz < 0 ) tz += Lz;
	                      while( tz >= Lz ) tz -= Lz;
	
	                      int zb = N_BINS_MOLDIST * tz / Lz; // this is right
	                      if( zb < 0 ) zb = 0;
	                      if( zb >= N_BINS_MOLDIST ) zb = N_BINS_MOLDIST-1;
	                      moldist[zb] += 1;
			}
		}
	
	         for( int zb = 0; zb < N_BINS_MOLDIST; zb++ )
	         {
	                 double zv = Lz * (zb+0.5) / (double)N_BINS_MOLDIST;
	 
	                  int zlow  = zb- N_BINS_MOLDIST/2;
	                  int zhigh = zlow + N_BINS_MOLDIST;
	 
	                  double Lzhi2 = 0;
	                  for( int iz = zlow; iz < zhigh; iz++ )
	                  {
	                          double dz = Lz * (iz+0.5) / N_BINS_MOLDIST - zv;
	 
	                          int iiz = iz;
	                          while( iiz < 0 ) iiz += N_BINS_MOLDIST;
	                          while( iiz >= N_BINS_MOLDIST ) iiz -= N_BINS_MOLDIST;
	 
	                          Lzhi2 += moldist[iiz] * (dz) * (dz);
	                  }
	 
	                  if( Lzhi2 < best_chi2 )
	                  {
	                          best_chi2 = Lzhi2;
	                          wrapto = zv;
	                  }
	         }
	
	
	
		// wrap around z periodic dimension
	
		for( int l = 0; l < nlipids; l++ )
		{
			int midlipid = (lipid_start[l]+lipid_stop[l])/2;
			while( at[midlipid].z - wrapto < -Lz/2 ) at[midlipid].z += Lz;
			while( at[midlipid].z - wrapto > Lz/2 ) at[midlipid].z -= Lz;
	
			double lcom_z = 0;
	
			for( int p = lipid_start[l]; p <= lipid_stop[l]; p++ )
			{
				while( at[p].x - at[midlipid].x < -Lx/2 ) at[p].x += Lx;
				while( at[p].x - at[midlipid].x >  Lx/2 ) at[p].x -= Lx;
				
				while( at[p].y - at[midlipid].y < -Ly/2 ) at[p].y += Ly;
				while( at[p].y - at[midlipid].y >  Ly/2 ) at[p].y -= Ly;
				
				while( at[p].z - at[midlipid].z < -Lz/2 ) at[p].z += Lz;
				while( at[p].z - at[midlipid].z >  Lz/2 ) at[p].z -= Lz;
		
				lcom_z += (at[p].z - wrapto);
			}
	
			if( lcom_z > 0 )
				leaflet[l] = 1;
			else
				leaflet[l] = -1;
		} 
	
		// subtract off wrapto
	
		for( int a = 0; a < curNAtoms(); a++ )
		{
			at[a].z -= wrapto;
//			if( at[a].atname[0] == 'N' ) printf("res %d z %lf\n", at[a].res, at[a].z );
		}
		// fill lipid positions
	
		for( int l = 0; l < nlipids; l++ )
		{
			lipid_xyz[3*l+0] = 0;	
			lipid_xyz[3*l+1] = 0;	
			lipid_xyz[3*l+2] = 0;
		
			for( int p = lipid_start[l]; p <= lipid_stop[l]; p++ )
			{
				lipid_xyz[3*l+0] += at[p].x;
				lipid_xyz[3*l+1] += at[p].y;
				lipid_xyz[3*l+2] += at[p].z;
			}
	
			lipid_xyz[3*l+0] /= (lipid_stop[l] - lipid_start[l] + 1 );
			lipid_xyz[3*l+1] /= (lipid_stop[l] - lipid_start[l] + 1 );
			lipid_xyz[3*l+2] /= (lipid_stop[l] - lipid_start[l] + 1 );
		}


		master_nlipids[pass] = nlipids;
	}

	if( do_leaflet[0] > 0 && do_leaflet[1] == -1 )
		do_leaflet[1] = 0;
	else if( do_leaflet[1] > 0 && do_leaflet[0] == -1 )
		do_leaflet[0] = 0;

	int nrim = 0;
	double *rimt = NULL;
	double rim_center[3]={0,0,0};
	double rim_extent = 0;
	// get regions of the bilayer which we will map collectively attempting to leave a minimum of seams.

	int *regions_for_face = (int *)malloc( sizeof(int) * nt );
	int *regions_for_tri = (int *)malloc( sizeof(int) * nt );

	double cur_area,area0;
	area(rsurf,-1, &cur_area,&area0);

	// Expected TOTAL neutral surface area.		
	// A0*(1 + J * PP + K * PP * PP ) 

	double JZ =0;
	double KZ =0;
	double Z = 0;
	for( int f = 0; f < nt; f++ )
	{
		double u_cen=1.0/3.0;
		double v_cen=1.0/3.0;

		double cvec1[2] = {0,0}, cvec2[2]={0,0};
		double gv = g(f, 1.0/3.0, 1.0/3.0, rsurf );
		double c1=0,c2=0;
		double k;
		double ctot = c(f,u_cen,v_cen,rsurf,&k,cvec1,cvec2,&c1,&c2);
		
		JZ += (c1+c2)*gv;
		KZ += c1*c2 * gv;
	        Z  += gv;
	}

	JZ /= Z;
	KZ /= Z;

	double PP_in   = (1-JZ*PP)*PP * exp(-block->strainInner);
	double PP_out  = (1+JZ*PP)*PP * exp(-block->strainOuter);

	double area_target_outside = area0 * (1 + JZ * PP_out + KZ * PP * PP )* exp(-0.5*block->strainOuter);
	double area_target_inside  = area0 * (1 - JZ * PP_in + KZ * PP * PP )*exp(-0.5*block->strainInner);
	printf("Area-midplane: %le Area_NS/PP_outside: %le\n", area0, area_target_outside );
	printf("Area-midplane: %le Area_NS/PP_inside:  %le\n", area0, area_target_inside  );

	double use_area_lower = master_Lx[0]*master_Ly[0];
	double use_area_upper = master_Lx[1]*master_Ly[1];
	
	int nregions = 0;
	if( do_leaflet[0] && do_leaflet[1] )
		nregions = area0 / ( (use_area_lower+use_area_upper)/8);
	else if( do_leaflet[0] )
		nregions = area0 / ( (use_area_lower)/4);
	else
		nregions = area0 / ( (use_area_upper)/4);

	nregions = nt/4;

//	nregions *= 2;
	if( nregions > nt )
		nregions = nt;	
	//int debug_ids[3] = { 24, 26, 77 };
	//int debug_ids[3] = { 26, 77, 100 };
	int debug_ids[3] = { 47, 51, 117 };
	int debug_t = -1;
	int debug_f = -1;

	for( int t = 0; t < nt; t++ )
	{
		int tids[3] = {theTriangles[t].ids[0],theTriangles[t].ids[1],theTriangles[t].ids[2] };
		sort3(tids);

		if( 
			tids[0] == debug_ids[0] &&	
			tids[1] == debug_ids[1] &&	
			tids[2] == debug_ids[2] )	
		{
			debug_t = t;
			debug_f = theTriangles[t].f;
		}
	}

	if( nregions > nt / 2 )
	{
		nregions = nt;
		for( int t = 0;  t < nt; t++ )
		{
			regions_for_tri[t] = t;
			regions_for_face[theTriangles[t].f] = t;
		}
	}
	else
	{
	// target one fourth of the area?

	printf("Using %d regions.\n", nregions );

	getRegions(regions_for_tri, nregions );

	for( int t = 0;  t < nt; t++ )
		regions_for_face[theTriangles[t].f] = regions_for_tri[t];
	}
	// Eventually I'd like to place lipids with as few seams,
	// and as little lateral tension inhomogeneity as possible.
	// for now I'll just put them on the faces.

	int *tri_list = (int *)malloc( sizeof(int) * nt );

	int cur_natoms = 0;
	int cur_atom = 1;
	int cur_res  = 1;

	FILE *tempFile = fopen("temp.crd","w");


	const char *atom_name[] = 
	{	
		"H",
		"He",
		"Li",
		"Be",
		"B",
		"C",
		"N",
		"O",
		"F",
		"Na",
		"K",
		"Cl"		
	};

	int natom_names = sizeof(atom_name)/sizeof(const char*);
	
	int cur_size = 0;
	int cur_space = 1024;
	char *cur_segment = (char *)malloc( sizeof(char) * cur_space );
	cur_segment[0] = '\0';
	char *cur_filename = (char *)malloc( sizeof(char) * 1024 );
	char *cur_segname = (char *)malloc( sizeof(char) * 1024 );	

	int seg_cntr = 1;


	int npairs = 0;
	int npair_space = 10;
	crd_psf_pair *pairs = (crd_psf_pair *)malloc( sizeof(crd_psf_pair) * npair_space );


	double area_fraction_outside = 1.0;
	double area_fraction_inside = 1.0;

	const char *out_in[3]= {"IN","OUT", "RIM"};
			
	sprintf(cur_filename, "segment_%s%d.crd", out_in[0], seg_cntr );
	sprintf(cur_segname, "%s%d", out_in[0], seg_cntr ); 

	int seed = rand();
	int patch_warning = 0; // cntr for warning about large patches
	int nplaced = 0;
	int nplacedSpace = 100;
	double *placed_atoms = (double *)malloc( sizeof(double) * 3 * nplacedSpace );

	double av_P_xy[2] = {0,0};
	double nav_P[2] = {0,0};
	
	double rel_vol[2] = {0,0};

	double **M;
	int mlow = 5;
	int mhigh = 7;

	getM(&M,&mlow,&mhigh);	
	
	if( block->addSalt )
	{
		printf("Computing relative volumes inside/outside.\n");

		int n_vol_mc = 1000;

		for( int i = 0; i < n_vol_mc; i++ )
		{
			double rpt[3] = { rand()/(double)RAND_MAX * PBC_vec[0][0],
					  rand()/(double)RAND_MAX * PBC_vec[1][1],
					  rand()/(double)RAND_MAX * PBC_vec[2][2] };
		
			int f;
			double u, v;
			double distance;

			nearPointOnBoxedSurface( rpt, &f, &u, &v, M, mlow, mhigh, &distance, 0 );	
			double nearp[3], nearn[3];
                	evaluateRNRM( f, u, v, nearp, nearn, rsurf );

			double dr[3] = { rpt[0] - nearp[0], rpt[1] - nearp[1], rpt[2] - nearp[2] };
			wrapPBC( dr, rsurf+3*nv );
	
			double io = dr[0] * nearn[0] + dr[1] * nearn[1] + dr[2] * nearn[2];

			if( io < 0 ) // displacement and normal are oppositely aligned, inside the surface (relative to the normal convention) 
				rel_vol[0] += 1;
			else
				rel_vol[1] += 1;	
		}


		printf("rel vol: %lf %lf\n", rel_vol[0], rel_vol[1] );
	}

	double zero_vec[3] = {0,0,0};
	int *regional_face = (int *)malloc( sizeof(int) * nt );
	memset( regional_face, 0, sizeof(int) * nt );
	

	double boxl = 20.0;

	int nx = PBC_vec[0][0] / boxl;
	int ny = PBC_vec[1][1] / boxl;
	int nz = PBC_vec[2][2] / boxl;

	if( nx > 100 ) nx = 100;
	if( ny > 100 ) ny = 100;
	if( nz > 100 ) nz = 100;

	double box_x = PBC_vec[0][0] / nx;
	double box_y = PBC_vec[1][1] / ny;
	double box_z = PBC_vec[2][2] / nz;

	caa_box *theBoxes = (caa_box *)malloc( sizeof(caa_box) * nx * ny * nz );

	for( int b = 0; b < nx*ny*nz; b++ )
	{
		theBoxes[b].np = 0;
		theBoxes[b].npSpace = 2;
		theBoxes[b].plist = (int *)malloc( sizeof(int) * theBoxes[b].npSpace );
	}

	// if we are working on GM1 we need to write the patches into the input file.
	int gm1_switch =0;

	for( int pass = 0; pass < 2; pass++ )
	{

		srand(seed); // generate the same random numbers.

		double alpha_outside = 1;
		double alpha_inside  = 1;

		if( pass == 1 )
		{
			alpha_outside = sqrt(area_fraction_outside);
			alpha_inside = sqrt(area_fraction_inside);
		}
		int nlipids_placed = 0;
		int nlipids_placed_outside = 0;
		int nlipids_placed_inside = 0;
		int switched = 0;
		for( int x_leaflet = 0; x_leaflet < 2; x_leaflet++ )
		{
			if( do_leaflet[x_leaflet] == 0 ) continue;
			double strain[2] = { block->strainInner, block->strainOuter };

			int *leaflet = master_leaflet[x_leaflet];
			double *lipid_xyz = master_lipid_xyz[x_leaflet];
			struct atom_rec *at = master_at[x_leaflet];
			int *lipid_stop = master_lipid_stop[x_leaflet];
			int *lipid_start = master_lipid_start[x_leaflet];
			int nlipids = master_nlipids[x_leaflet];


			int **local_cycles = master_cycles[x_leaflet];
			int *local_cycle_len = master_cycle_lengths[x_leaflet];
			int local_ncycles = master_ncycles[x_leaflet];
			
			int *local_bonds = master_bonds[x_leaflet];
			int *local_nbonds = master_nbonds[x_leaflet];
			int *local_bond_offsets = master_bond_offsets[x_leaflet];

			double Lx = master_Lx[x_leaflet];
			double Ly = master_Ly[x_leaflet];
			double Lz = master_Lz[x_leaflet];
			for( int r = 0; r < nregions; r++ )
			{
				printf("DOING REGION %d\n", r );
				int N = 0;
		
				double tri_cen[3] = {0,0,0};
		
				int debug_me = 0;
				double patch_area = 0;

				for( int t = 0; t < nt; t++ )
				{
					if( regions_for_face[t] == r )
					{
						regional_face[t] = 1;
		//				if( t == debug_f )
							//debug_me = 1;
						double rc[3],nc[3];
						evaluateRNRM( t, 1.0/3.0, 1.0/3.0, rc, nc, rsurf );
	
						double *v1 = rsurf + 3 * theTriangles[t].ids[0];
						double *v2 = rsurf + 3 * theTriangles[t].ids[1];
						double *v3 = rsurf + 3 * theTriangles[t].ids[2];
			
						patch_area += 0.5 * g( t, 1.0/3.0, 1.0/3.0, rsurf ) ;	
						

		//				if( r < natom_names )
		//				printf("%s %lf %lf %lf\n", atom_name[r], rc[0], rc[1], rc[2] );
		
						if( N == 0 )
						{
							tri_cen[0] += rc[0];
							tri_cen[1] += rc[1];
							tri_cen[2] += rc[2];
						}	
						else
						{
							double dr[3] = { rc[0] - tri_cen[0]/N, rc[1] - tri_cen[1]/N, rc[2] - tri_cen[2]/N };
							wrapPBC( dr, rsurf+3*nv );
		
							tri_cen[0] += tri_cen[0]/N + dr[0];	
							tri_cen[1] += tri_cen[1]/N + dr[1];	
							tri_cen[2] += tri_cen[2]/N + dr[2];	
						}
		
						tri_list[N] = t; 
						N++; 
					}
				}
		
				tri_cen[0] /= N;
				tri_cen[1] /= N;
				tri_cen[2] /= N;
		
				double best_chi2 = 1e10;
				int best_x = 0;
				for( int xt = 0; xt < N; xt++ )
				{
					int f = tri_list[xt];
		
					double rc[3],nc[3];
					evaluateRNRM( f, 1.0/3.0, 1.0/3.0, rc, nc, rsurf );
		
					double dr[3] = { rc[0] - tri_cen[0], rc[1] - tri_cen[1], rc[2] - tri_cen[2] };
			
					wrapPBC( dr, rsurf+3*nv );
		
					double r = normalize(dr);
		
					if( f >= nf_faces )
						r += 1e8;
		
					if( r < best_chi2 )
					{
						best_chi2 = r;
						best_x = xt;
					}
				}
		
				int f = tri_list[best_x]; 

				// pick a lipid on the upper leaflet to put in the center of the face.
			
				double alpha = alpha_outside;
				if( x_leaflet == 0 )
					alpha = alpha_inside;
				int l_cen = rand() % nlipids;
	
				while( leaflet[l_cen] != (x_leaflet ? 1 : -1 ) )
					l_cen = rand() % nlipids; 
	
			
				// loop over all lipids. if they are in the face, place them into the coord structure.
			
				double upper_cen[3] = { lipid_xyz[3*l_cen+0], lipid_xyz[3*l_cen+1], lipid_xyz[3*l_cen+2] };
			
				// x, y to u, v'
			
			
				double sim_area = Lx*Ly;

				int del_PBC_x = 1;
				int del_PBC_y = 1;
				if( sim_area / patch_area < 2)
				{
					del_PBC_x = 1+(int)ceil(sqrt(patch_area/sim_area));
					del_PBC_y = 1+(int)ceil(sqrt(patch_area/sim_area));
				}

				if( del_PBC_x > 5 && patch_warning < 5)
				{
					printf("WARNING: PATCH AREAS ARE VERY LARGE COMPARED TO SIMULATION.\n");
					patch_warning += 1;
				}
				for( int l = 0; l < nlipids; l++ )
				for( int dx_pbc = -del_PBC_x; dx_pbc <= del_PBC_x; dx_pbc += 1 )
				for( int dy_pbc = -del_PBC_x; dy_pbc <= del_PBC_x; dy_pbc += 1 )
				{
				
					if( leaflet[l] != leaflet[l_cen] ) continue;
	//				if( l != l_cen ) continue;
					// if the segment is a protein or glycosphingolipid we'll try to help the user with patch commands.
	
		
					// map the r coords to u/v
			
					double dx = lipid_xyz[3*l+0]-upper_cen[0];
					double dy = lipid_xyz[3*l+1]-upper_cen[1];
		
					double shift[2] = {dx_pbc * Lx, dy_pbc * Ly};
					while( dx < -Lx/2 ) {dx += Lx; shift[0] += Lx; }
					while( dx >  Lx/2 ) {dx -= Lx; shift[0] -= Lx; }
					while( dy < -Ly/2 ) {dy += Ly; shift[1] += Ly; }
					while( dy >  Ly/2 ) {dy -= Ly; shift[1] -= Ly; }
			
					dx += dx_pbc * Lx;
					dy += dy_pbc * Ly;
	
					double use_r[3] = { alpha * dx, alpha * dy, lipid_xyz[3*l+2] };
					double eval_cen[3];
		
					double spot_u = 1.0/3.0;
					double spot_v = 1.0/3.0;
	
	
					int main_f_eval = f;
					double main_u_cen = spot_u;
					double main_v_cen = spot_v;
					int ncrosses = 0;	

					// everything must be evaluated at this spot to retain the x,y to u/v mapping.
#if METHOD_ONE
					int fout = evaluate_at( eval_cen, use_r, f, &spot_u, &spot_v, rsurf, leaflet[l], -strain[x_leaflet] );
#else
					// get the x/y/z coordinate system transported to the distance spot (as determined by use_r)
					double dx_uv[2], dy_uv[2];
					double source_r[3] = { alpha * dx, alpha * dy, lipid_xyz[3*l+2] };
					int fout = getCoordinateSystem( f, &spot_u, &spot_v, source_r, -strain[x_leaflet], leaflet[l],
							dx_uv, dy_uv, rsurf, regional_face, &ncrosses ); 
					if( debug_me && x_leaflet == 1 && pass == 1)
					{
						double rpt[3], rnrm[3];
						evaluateRNRM( fout, spot_u, spot_v, rpt,rnrm, rsurf );
							
						if( regions_for_face[fout]== r )
						{
							printf("N %lf %lf %lf # ncrosses %d\n", source_r[0], source_r[1], source_r[2], ncrosses );
							printf("C %lf %lf %lf # ncrosses %d lipid %d\n", rpt[0], rpt[1], rpt[2], ncrosses, l );
						}
						else
						{
							printf("F %lf %lf %lf\n", source_r[0], source_r[1], source_r[2] );
							printf("O %lf %lf %lf\n", rpt[0], rpt[1], rpt[2] );
						}
//						printf("%lf %lf evaluates to %d %lf %lf %s\n", source_r[0], source_r[1], fout, spot_u, spot_v, (regions_for_face[fout]== r ? "INSIDE" : "OUTSIDE") ); 
					}
#endif
					
					double w_use = 1.0;
					double w_rim = 0.0;
					double rimp[3] = {0,0,0};
					double rimn[3] = {0,0,0};

					int debug_mode = 0;
					if( !strcasecmp( cur_segname, "IN8" ) )
					{	
						debug_mode = 1;
					}

					if( block->create_pore > 0 )
					{
						double nrm[3];
						double rpt[3];
		
						evaluateRNRM( fout, spot_u, spot_v, rpt, nrm, rsurf );
					
						double dr[3] = { rpt[0], rpt[1], rpt[2] };
						wrapPBC( dr, rsurf+3*nv );

						double r = normalize(dr);

						if( r < block->create_pore ) continue;
					}

					if( nrim > 0 )
					{
						double nrm[3];
						double rpt[3];
		
						evaluateRNRM( fout, spot_u, spot_v, rpt, nrm, rsurf );
		
						// check the distance to each triangle, see if it's less than PP.
					
						double testp[3] = { 
							rpt[0] + nrm[0] * (x_leaflet ? 1 : -1 ) * PP,
							rpt[1] + nrm[1] * (x_leaflet ? 1 : -1 ) * PP,
							rpt[2] + nrm[2] * (x_leaflet ? 1 : -1 ) * PP };

						int neart = -1;
						double neard = 1e10;
						double rim_fudge = 0; //PP;

						for( int rt = 0; rt < nrim; rt++ )
						{
							double nearp[3];
							double output[3];
							if( nearInteriorPointOnTriangle( testp, rimt+9*rt, rimt+9*rt+3, rimt+9*rt+6, output ) )
							{
								double check_dr[3] = { testp[0] - output[0], testp[1] - output[1], testp[2] - output[2] };
								double lc = normalize(check_dr);

								if( lc < neard && lc < PP + rim_fudge )
								{
									neard = lc;
									neart = rt;
				
									w_use = pow(1.0 / PP,1.0);
									w_rim = pow(1.0 / lc,1.0);

									double wsum = w_use+w_rim;

									w_use /= wsum;
									w_rim /= wsum;

									rimp[0] = (output[0] - rpt[0]) * w_rim;
									rimp[1] = (output[1] - rpt[1]) * w_rim;
									rimp[2] = (output[2] - rpt[2]) * w_rim;

									rimn[0] = 0;
									rimn[1] = 0;
									rimn[2] = 1;

									if( testp[2] < output[2] )
										rimn[2] = -1; 
								}
							}	
						}

					}			
	
		
					if( regions_for_face[fout] == r && ncrosses < 5)
					{
						nlipids_placed += 1;
						if( x_leaflet == 0 )
							nlipids_placed_inside += 1;
						else
							nlipids_placed_outside += 1;
	
						if( pass == 0 ) continue;	

						int base_res = cur_res; 
	
						if( cur_size > 0 && (!strncasecmp( at[lipid_start[l]].segid, "GLPA", 4) || cur_res > 50 || switched) )
							EndSegment( charmmFile, cur_filename, cur_segment, cur_segname, &pairs, &seg_cntr, &npairs, &npair_space, x_leaflet,
									&cur_size, &cur_natoms, &cur_atom,  &cur_res, &switched, gm1_switch );

						double u_cen = spot_u;
						double v_cen = spot_v;

						for( int test_iters = 0; test_iters < 10; test_iters++ )
						{
							if( TestAdd( this, l, lipid_start, lipid_stop, at,
								shift, upper_cen, zero_vec, alpha, 
								main_u_cen, main_v_cen,
								use_r, source_r,
								spot_u, spot_v,
								fout, rsurf,
								leaflet[l],
								-strain[x_leaflet],
								dx_uv, dy_uv,
								w_use, w_rim, rimp, rimn,
								x_leaflet, total_lipid_charge,
								&cur_atom, &cur_natoms,
								&placed_atoms, &nplaced, &nplacedSpace,
								cur_segname, &cur_segment, &cur_size, &cur_space, &cur_res, theBoxes, nx, ny, nz,
local_cycles, local_cycle_len, local_ncycles,
local_bonds, local_nbonds, local_bond_offsets, doubleBondIndexes ) )
							{
								if( !strncasecmp( at[lipid_start[l]].segid, "GLPA", 4) )
									gm1_switch = 1;
								else
									gm1_switch = 0;
								cur_res++;
						
								if( cur_size > 0 && !strncasecmp( at[lipid_start[l]].segid, "GLPA", 4) )
									EndSegment( charmmFile, cur_filename, cur_segment, cur_segname, &pairs, &seg_cntr, &npairs, &npair_space, x_leaflet,
										&cur_size, &cur_natoms,&cur_atom,  &cur_res, &switched, gm1_switch );

								break;
							}
						}
					}
				}

				memset( regional_face, 0, sizeof(int) * nt );
			}
			
			if( nrim > 0 )
			{
				if( cur_size > 0 )
				EndSegment( charmmFile, cur_filename, cur_segment, cur_segname, &pairs, &seg_cntr, &npairs, &npair_space, 2 /* force rim */,
					&cur_size, &cur_natoms, &cur_atom,  &cur_res, &switched, gm1_switch );
				int alt_leaflet = 2;

				int *leaflet = master_leaflet[alt_leaflet];
				double *lipid_xyz = master_lipid_xyz[alt_leaflet];
				struct atom_rec *at = master_at[alt_leaflet];
				int *lipid_stop = master_lipid_stop[alt_leaflet];
				int *lipid_start = master_lipid_start[alt_leaflet];
				int nlipids = master_nlipids[alt_leaflet];
				double Lx = master_Lx[alt_leaflet];
				double Ly = master_Ly[alt_leaflet];
				double Lz = master_Lz[alt_leaflet];

				alpha = alpha_inside;
				// put bilayer into the rim region.
				
				int l_cen = rand() % nlipids;
	
				while( leaflet[l_cen] != (x_leaflet ? 1 : -1 ) )
					l_cen = rand() % nlipids; 
				
				double upper_cen[3] = { lipid_xyz[3*l_cen+0], lipid_xyz[3*l_cen+1], lipid_xyz[3*l_cen+2] };
				
				for( int ix = -1; ix <= 1; ix++ )
				for( int iy = -1; iy <= 1; iy++ )
				{
					for( int l = 0; l < nlipids; l++ )
					{
						if( leaflet[l] != leaflet[l_cen] ) continue;
	
					// map the r coords to u/v
			
						double dx = lipid_xyz[3*l+0]-upper_cen[0];
						double dy = lipid_xyz[3*l+1]-upper_cen[1];
		
						double shift[2] = {0,0};
						while( dx < -Lx/2 ) {dx += Lx; shift[0] += Lx; }
						while( dx >  Lx/2 ) {dx -= Lx; shift[0] -= Lx; }
						while( dy < -Ly/2 ) {dy += Ly; shift[1] += Ly; }
						while( dy >  Ly/2 ) {dy -= Ly; shift[1] -= Ly; }
				
						double use_r[3] = { alpha * dx + ix * Lx, alpha * dy + iy * Ly, lipid_xyz[3*l+2] };
						double rim_dr[3] = { use_r[0] ,
								 use_r[1] ,
								 use_r[2]};
	
						double ur = sqrt(rim_dr[0]*rim_dr[0]+rim_dr[1]*rim_dr[1]+rim_dr[2]*rim_dr[2]);

						if( ur < rim_extent - PP )
						{
							// print it out
						
							double wrap_to[3] = { 0,0,0};
						
							if( cur_size > 0 && (!strncasecmp( at[lipid_start[l]].segid, "GLPA", 4) || cur_res > 50 || switched) )
							{	
								
								EndSegment( charmmFile, cur_filename, cur_segment, cur_segname, &pairs, &seg_cntr, &npairs, &npair_space, x_leaflet,
									&cur_size, &cur_natoms,&cur_atom,  &cur_res, &switched, gm1_switch );
									
								sprintf(cur_filename, "segment_%s%d.crd", out_in[x_leaflet], seg_cntr );
								sprintf(cur_segname, "%s%d", out_in[x_leaflet], seg_cntr ); 
							
								cur_size = 0;
								cur_natoms = 0;
								cur_segment[0] = '\0';
								cur_atom = 1;
								cur_res  = 1;
								switched=0;
							}
							
							TestAddRim( this, l, lipid_start, lipid_stop, at,
								dx, dy, lipid_xyz,
								shift, upper_cen, rim_center,
								alpha,
								use_r, 
								rsurf,
								leaflet[l],
								x_leaflet, total_lipid_charge,
								&cur_atom, &cur_natoms,
								&placed_atoms, &nplaced, &nplacedSpace,
								cur_segname, &cur_segment, &cur_size, &cur_space, &cur_res, theBoxes, nx, ny, nz, local_cycles, local_cycle_len, local_ncycles, local_bonds, local_nbonds, local_bond_offsets);
						
							if( !strncasecmp( at[lipid_start[l]].segid, "GLPA", 4) )
								gm1_switch = 1;
							else
								gm1_switch = 0;
							cur_res++;
						
							if( cur_size > 0 && !strncasecmp( at[lipid_start[l]].segid, "GLPA", 4) )
							EndSegment( charmmFile, cur_filename, cur_segment, cur_segname, &pairs, &seg_cntr, &npairs, &npair_space, x_leaflet,
									&cur_size, &cur_natoms,&cur_atom,  &cur_res, &switched, gm1_switch );
						}
					}	
				}
				
				if( cur_size > 0 )
				EndSegment( charmmFile, cur_filename, cur_segment, cur_segname, &pairs, &seg_cntr, &npairs, &npair_space, x_leaflet,
					&cur_size, &cur_natoms, &cur_atom,  &cur_res, &switched, gm1_switch );
			}

			switched = 1;
		}

		printf("Nlipids placed outside: %d nlipids placed inside: %d\n", nlipids_placed_outside, nlipids_placed_inside);
		
		double likely_area_covered_outside = nlipids_placed_outside * master_Lx[1] * master_Ly[1] / (1e-10 + master_nlipids[1]/2);
		double likely_area_covered_inside = nlipids_placed_inside  * master_Lx[0] * master_Ly[0] / ( 1e-10 + master_nlipids[0]/2);

		area_fraction_outside = likely_area_covered_outside / area_target_outside;
		area_fraction_inside = likely_area_covered_inside / area_target_inside;

		printf("PASS %d area percentage: %lf%% outside %lf%% inside.\n", pass, 100*area_fraction_outside, 100*area_fraction_inside );
	}

	printf("P_in: %le P_out: %le\n",
		av_P_xy[0] / nav_P[0], 
		av_P_xy[1] / nav_P[1] );

	int junk = 0;
	if( cur_size > 0 )
		EndSegment( charmmFile, cur_filename, cur_segment, cur_segname, &pairs, &seg_cntr, &npairs, &npair_space, junk,
				&cur_size, &cur_natoms,&cur_atom,  &cur_res, &junk, gm1_switch );


	if( nprotein > 0 )
	{
		nplacedSpace += nprotein;
		placed_atoms = (double *)realloc( placed_atoms, sizeof(double) * 3 * nplacedSpace );

		for( int px = 0; px < nprotein; px++ )
		{
			placed_atoms[3*nplaced+0] = protein[px].x;
			placed_atoms[3*nplaced+1] = protein[px].y;
			placed_atoms[3*nplaced+2] = protein[px].z;

			boxit( placed_atoms+3*nplaced, nplaced, theBoxes, PBC_vec, nx, ny, nz );

			nplaced++;
		}
	}

	for( int px = 0; px < nplaced; px++ )
	{
		double r[3] = { placed_atoms[3*px+0], placed_atoms[3*px+1], placed_atoms[3*px+2] };

		while( r[0] <  0 ) r[0] += PBC_vec[0][0];
		while( r[1] <  0 ) r[1] += PBC_vec[1][1];
		while( r[2] <  0 ) r[2] += PBC_vec[2][2];
		while( r[0] >  PBC_vec[0][0] ) r[0] -= PBC_vec[0][0];
		while( r[1] >  PBC_vec[1][1] ) r[1] -= PBC_vec[1][1];
		while( r[2] >  PBC_vec[2][2] ) r[2] -= PBC_vec[2][2];

		int bx = r[0] * nx / PBC_vec[0][0];
		int by = r[1] * ny / PBC_vec[1][1];
		int bz = r[2] * nz / PBC_vec[2][2];

		if( bx >= nx ) bx -= nx;
		if( bx < 0 ) bx += nx;
		if( by >= ny ) by -= ny;
		if( by < 0 ) by += ny;
		if( bz >= nz ) bz -= nz;
		if( bz < 0 ) bz += nz;

		int b = bx*ny*nz+by*nz+bz;
		if( theBoxes[b].np == theBoxes[b].npSpace )
		{
			theBoxes[b].npSpace *= 2;
			theBoxes[b].plist = (int * )realloc( theBoxes[b].plist, sizeof(int) * theBoxes[b].npSpace );
		}

		theBoxes[b].plist[theBoxes[b].np] = px;
		theBoxes[b].np += 1;
	}
	
	total_charge = total_protein_charge + total_lipid_charge[0] + total_lipid_charge[1];

	
	/* Solvate */

	int wrote_water_psf = 0;
	char waterFileName[256];
	char waterPSFName[256];
	int water_atom = 1;
	int nK[2] = {0,0};
	int nCl[2] = {0,0};
	if( nsolvate > 0 )
	{
		// we need to loop over a sufficient number of solvent periodic boxes to cover the main PBC cell.
		
		int nsolvent_x = ceil(PBC_vec[0][0] / solvate_PBC[0]);
		int nsolvent_y = ceil(PBC_vec[1][1] / solvate_PBC[1]);
		int nsolvent_z = ceil(PBC_vec[2][2] / solvate_PBC[2]);

		// we don't want to do solvent PBC loops over the main cell. we only want to keep residues that are inside the box.
		// make sure the interior coordinates are centered properly.

		// get solvent residue structure in the form of an index.
		int nsolventRes =0;
		int *solvent_res_link = (int *)malloc( sizeof(int) * nsolvate );
		int *solvent_res_size = (int *)malloc( sizeof(int) * nsolvate );

		int pres = -1;
		for( int a = 0; a < nsolvate; a++ )
		{
			if( solvate[a].res != pres )
			{
				if( nsolventRes > 0 )
					solvent_res_size[nsolventRes-1] = a - solvent_res_link[nsolventRes-1];
				solvent_res_link[nsolventRes] = a;
				nsolventRes++;
			}

			pres = solvate[a].res;
		}
				
		solvent_res_size[nsolventRes-1] = nsolvate - solvent_res_link[nsolventRes-1];
		
		printf("%d solvent residues.\n", nsolventRes );

		for( int r = 0; r < nsolventRes; r++ )
		{
			double com[3] = {0,0,0};

			for( int ax = 0; ax < solvent_res_size[r]; ax++ )
			{	
				int a = solvent_res_link[r] + ax;
				com[0] += solvate[a].x;
				com[1] += solvate[a].y;
				com[2] += solvate[a].z;
			}

			com[0] /= solvent_res_size[r];
			com[1] /= solvent_res_size[r];
			com[2] /= solvent_res_size[r];
			
			double shift[3] = {0,0,0};
			while( com[0] + shift[0] < -solvate_PBC[0]/2 ) shift[0] += solvate_PBC[0];
			while( com[1] + shift[1] < -solvate_PBC[1]/2 ) shift[1] += solvate_PBC[1];
			while( com[2] + shift[2] < -solvate_PBC[2]/2 ) shift[2] += solvate_PBC[2];
			while( com[0] + shift[0] > solvate_PBC[0]/2 ) shift[0] -= solvate_PBC[0];
			while( com[1] + shift[1] > solvate_PBC[1]/2 ) shift[1] -= solvate_PBC[1];
			while( com[2] + shift[2] > solvate_PBC[2]/2 ) shift[2] -= solvate_PBC[2];

			for( int ax = 0; ax < solvent_res_size[r]; ax++ )
			{	
				int a = solvent_res_link[r] + ax;

				solvate[a].x += shift[0];
				solvate[a].y += shift[1];
				solvate[a].z += shift[2];
			}
		}


//		double solvation_shift[3] = 
//			{
//				( nsolvent_x * solvate_PBC[0]- PBC_vec[0][0])/2, 
//				( nsolvent_y * solvate_PBC[1]- PBC_vec[1][1])/2, 
//				( nsolvent_z * solvate_PBC[2]- PBC_vec[2][2])/2
//			};	
	
		printf("WATER PBC: %lf %lf %lf\n", nsolvent_x * solvate_PBC[0],
						   nsolvent_y * solvate_PBC[1],	
						   nsolvent_z * solvate_PBC[2] );	
		sprintf(waterFileName, "solvate_%s.crd", block->jobName );

		FILE *waterCRD = fopen(waterFileName, "w" );
		int nprint_solvate = 0;	
		int water_size = 0;
		int water_space =4096;
		char *water_file = (char *)malloc( sizeof(char) * water_space );	 
		water_file[0] = '\0';
		char solventSegName[256];
		sprintf(solventSegName, "WAT");
		int water_res = 1;
		
		double tiling_min[3] =
		{ -solvate_PBC[0]/2, -solvate_PBC[1]/2, -solvate_PBC[2]/2 };
		double tiling_max[3] =
		{ (0.5 + nsolvent_x-1 ) * solvate_PBC[0], 
		  (0.5 + nsolvent_y-1 ) * solvate_PBC[1], 
		  (0.5 + nsolvent_z-1 ) * solvate_PBC[2] };
	
		double tile_center_shift[3] = { 
				 - (tiling_min[0]+tiling_max[0])/2,
				 - (tiling_min[1]+tiling_max[1])/2,
				 - (tiling_min[2]+tiling_max[2])/2 };

		for( int sx = 0; sx < nsolvent_x; sx++ )
		for( int sy = 0; sy < nsolvent_y; sy++ )
		for( int sz = 0; sz < nsolvent_z; sz++ )
		{
			double outer_shift[3] = { 
				tile_center_shift[0] + sx * solvate_PBC[0],
				tile_center_shift[1] + sy * solvate_PBC[1],
				tile_center_shift[2] + sz * solvate_PBC[2] };
		
			for( int r = 0; r < nsolventRes; r++ )
			{	
				double rcom[3] = {0,0,0};
		
				for( int ax = 0; ax < solvent_res_size[r]; ax++ )
				{
					int a = solvent_res_link[r] + ax;
					rcom[0] += solvate[a].x;
					rcom[1] += solvate[a].y;
					rcom[2] += solvate[a].z;
				}	

				rcom[0] /= solvent_res_size[r];
				rcom[1] /= solvent_res_size[r];
				rcom[2] /= solvent_res_size[r];
			
				double sub_shift[3] = { 0,0,0};
				for( int c = 0; c < 3; c++ )
				{
					while( rcom[c] +sub_shift[c] < -solvate_PBC[c]/2 ) sub_shift[c] += solvate_PBC[c];				
					while( rcom[c] +sub_shift[c] >  solvate_PBC[c]/2 ) sub_shift[c] -= solvate_PBC[c];				
				}
	
				outer_shift[0] += sub_shift[0];
				outer_shift[1] += sub_shift[1];
				outer_shift[2] += sub_shift[2];


				rcom[0] += outer_shift[0];
				rcom[1] += outer_shift[1];
				rcom[2] += outer_shift[2];

				if( ! block->perfect_solvent_tiling )
				{
					if( rcom[0] < -PBC_vec[0][0]/2 || rcom[0] >= PBC_vec[0][0]/2 ) continue;
					if( rcom[1] < -PBC_vec[1][1]/2 || rcom[1] >= PBC_vec[1][1]/2 ) continue;
					if( rcom[2] < -PBC_vec[2][2]/2 || rcom[2] >= PBC_vec[2][2]/2 ) continue;
				}

				int bx = rcom[0] * nx / PBC_vec[0][0];
				int by = rcom[1] * ny / PBC_vec[1][1];
				int bz = rcom[2] * nz / PBC_vec[2][2];
			
				if( bx >= nx ) bx -= nx;
				if( bx < 0 ) bx += nx;
				if( by >= ny ) by -= ny;
				if( by < 0 ) by += ny;
				if( bz >= nz ) bz -= nz;
				if( bz < 0 ) bz += nz;
	
				int b = bx*ny*nz+by*nz+bz;
				int bad_res = 0;
	
				for( int dx = -1; dx <= 1; dx++ )
				for( int dy = -1; dy <= 1; dy++ )
				for( int dz = -1; dz <= 1; dz++ )
				{
					int n_b_x = bx + dx;
					int n_b_y = by + dy;
					int n_b_z = bz + dz;
				
					if( n_b_x >= nx ) n_b_x -= nx;
					if( n_b_x < 0 ) n_b_x += nx;
					if( n_b_y >= ny ) n_b_y -= ny;
					if( n_b_y < 0 ) n_b_y += ny;
					if( n_b_z >= nz ) n_b_z -= nz;
					if( n_b_z < 0 ) n_b_z += nz;

					int nb = n_b_x*ny*nz+n_b_y*nz+n_b_z;


					for( int px = 0; px < theBoxes[nb].np; px++ )
					for( int ax = 0; ax < solvent_res_size[r]; ax++ )
					{
						int p = theBoxes[nb].plist[px];
						int a = solvent_res_link[r]+ax; 
						double dr[3] = { 
							placed_atoms[3*p+0] - (solvate[a].x + outer_shift[0]), 
							placed_atoms[3*p+1] - (solvate[a].y + outer_shift[1]),
							placed_atoms[3*p+2] - (solvate[a].z + outer_shift[2]) };
						while( dr[0] < -PBC_vec[0][0]/2 ) dr[0] += PBC_vec[0][0]; 
						while( dr[1] < -PBC_vec[1][1]/2 ) dr[1] += PBC_vec[1][1]; 
						while( dr[2] < -PBC_vec[2][2]/2 ) dr[2] += PBC_vec[2][2]; 
						while( dr[0] >  PBC_vec[0][0]/2 ) dr[0] -= PBC_vec[0][0]; 
						while( dr[1] >  PBC_vec[1][1]/2 ) dr[1] -= PBC_vec[1][1]; 
						while( dr[2] >  PBC_vec[2][2]/2 ) dr[2] -= PBC_vec[2][2];

						double dist = normalize(dr);

						if( dist < solvation_cutoff )
							bad_res = 1; 
					}
					if( bad_res ) break;
				}

				if( !bad_res )
				{	// add to the pool of water, ha ha.
					for( int ax = 0; ax < solvent_res_size[r]; ax++ )
					{
						int a = solvent_res_link[r] + ax;
						if( water_size + 1024 > water_space )
						{	
							water_space += 1024;
							water_file = (char *)realloc( water_file, sizeof(char) * water_space );
						}
						double savex = solvate[a].x;
						double savey = solvate[a].y;
						double savez = solvate[a].z;
						solvate[a].bead = water_atom;
						solvate[a].res = water_res;
						solvate[a].segRes = water_res;
						solvate[a].x += outer_shift[0];					
						solvate[a].y += outer_shift[1];					
						solvate[a].z += outer_shift[2];					
						char *tseg = solvate[a].segid;
						solvate[a].segid = solventSegName;
						printSingleCRD( water_file+water_size, solvate+a );
						water_size += strlen(water_file+water_size); // move to end of written string.
						nprint_solvate++;
						solvate[a].segid = tseg;
						solvate[a].x = savex;
						solvate[a].y = savey;
						solvate[a].z = savez;
						water_atom++;
					}
					water_res++;
				}

			}
		}	
								
		printCRDHeader( waterCRD, nprint_solvate );
		fprintf(waterCRD, "%s", water_file );
		fclose(waterCRD);

		free(water_file);
	
			fprintf(charmmFile, 
			"\n"
			"open read card unit 10 name \"%s\"\n"
			"read sequence coor card unit 10\n"
			"generate %s setup warn first none last none noangle nodihedral\n"
			"open read unit 10 card name \"%s\"\n"
			"read coor unit 10 card\n"						
			"\n", waterFileName, solventSegName, waterFileName );
	
		sprintf(waterPSFName, "%s.psf", solventSegName );

	
		fprintf(charmmFile, 
		"open write unit 10 card name \"%s.psf\"\n"
		"write psf  unit 10 card\n"
		, solventSegName );
		
		fprintf(charmmFile, "delete atom sele atom * * * end\n" );

		wrote_water_psf = 1;
	
		free(solvent_res_link);
		free(solvent_res_size);
	}

	int wrote_salt = 0;

	if( block->addSalt )
	{	
		printf("Total charge: %lf, %lf protein %lf lipid (inner) %lf lipid (outer).\n", total_charge, total_protein_charge, total_lipid_charge[0], total_lipid_charge[1] );
		// exterior and interior concentrations.

		double nwaters = (water_atom/3); 
		double water_vol_A3 = nwaters * 29; // cubic angstroms.
		double water_vol_L = water_vol_A3 * (1e-27);
	
		double water_vol[2]  = { 
			water_vol_L * (rel_vol[0] /(rel_vol[0]+rel_vol[1])),
			water_vol_L * (rel_vol[1] /(rel_vol[0]+rel_vol[1])) };

		double conc[2] = { block->innerKCL, block->outerKCL };

		double total_charge[2] = { total_lipid_charge[0], total_lipid_charge[1] + total_protein_charge };

		for( int leaflet = 0; leaflet < 2; leaflet++ )
		{
			// mMole:
			double nKCl_mMole = conc[leaflet] * water_vol[leaflet]; 
			double nKCl = nKCl_mMole * (6.022e20); // atoms per millimole.
		
			nK[leaflet] = nKCl;
			nCl[leaflet] = nKCl;
		
			if( total_charge[leaflet] < 0 )
				nK[leaflet] += lround(fabs(total_charge[leaflet]));
			else
				nCl[leaflet] += lround(fabs(total_charge[leaflet]));
		
			printf("Adding %d K %d Cl to the %s region.\n", nK[leaflet], nCl[leaflet], (leaflet == 0 ? "inner" : "outer") );
		}
		for( int pass = 0; pass < 2; pass++ )
		{
			int res = 1;	
			if( pass == 0 )
			{
				if( nK[0] + nK[1] > 0 )
				{
					fprintf(charmmFile, "read sequence POT %d\n", nK[0] + nK[1] );
					fprintf(charmmFile, "generate POT warn\n" );
				}
			}
			else
			{
				if( nCl[0] + nCl[1] > 0 )
				{
					fprintf(charmmFile, "read sequence CLA %d\n", nCl[0] + nCl[1] );
					fprintf(charmmFile, "generate CLA warn\n" );
				}
			}
			for( int leaflet = 0; leaflet < 2; leaflet++ )
			{
				for( int tk = 0; tk < (pass == 0 ? nK[leaflet] : nCl[leaflet]); tk++ )
				{
					int done = 0;
		
					double rp[3];
		
					while(!done)
					{
						rp[0] = -PBC_vec[0][0]/2 + PBC_vec[0][0] * rand()/(double)RAND_MAX;
						rp[1] = -PBC_vec[1][1]/2 + PBC_vec[1][1] * rand()/(double)RAND_MAX;
						rp[2] = -PBC_vec[2][2]/2 + PBC_vec[2][2] * rand()/(double)RAND_MAX; 
						int bx = rp[0] * nx / PBC_vec[0][0];
						int by = rp[1] * ny / PBC_vec[1][1];
						int bz = rp[2] * nz / PBC_vec[2][2];
					
						if( bx >= nx ) bx -= nx;
						if( bx < 0 ) bx += nx;
						if( by >= ny ) by -= ny;
						if( by < 0 ) by += ny;
						if( bz >= nz ) bz -= nz;
						if( bz < 0 ) bz += nz;
			
						int b = bx*ny*nz+by*nz+bz;
						int bad_res = 0;
	
						for( int dx = -1; dx <= 1; dx++ )
						for( int dy = -1; dy <= 1; dy++ )
						for( int dz = -1; dz <= 1; dz++ )
						{
							int n_b_x = bx + dx;
							int n_b_y = by + dy;
							int n_b_z = bz + dz;
						
							if( n_b_x >= nx ) n_b_x -= nx;
							if( n_b_x < 0 ) n_b_x += nx;
							if( n_b_y >= ny ) n_b_y -= ny;
							if( n_b_y < 0 ) n_b_y += ny;
							if( n_b_z >= nz ) n_b_z -= nz;
							if( n_b_z < 0 ) n_b_z += nz;
		
							int nb = n_b_x*ny*nz+n_b_y*nz+n_b_z;
		
		
							for( int px = 0; px < theBoxes[nb].np; px++ )
							{
								int p = theBoxes[nb].plist[px];
								double dr[3] = { 
									placed_atoms[3*p+0] - rp[0], 
									placed_atoms[3*p+1] - rp[1],
									placed_atoms[3*p+2] - rp[2] };
								while( dr[0] < -PBC_vec[0][0]/2 ) dr[0] += PBC_vec[0][0]; 
								while( dr[1] < -PBC_vec[1][1]/2 ) dr[1] += PBC_vec[1][1]; 
								while( dr[2] < -PBC_vec[2][2]/2 ) dr[2] += PBC_vec[2][2]; 
								while( dr[0] >  PBC_vec[0][0]/2 ) dr[0] -= PBC_vec[0][0]; 
								while( dr[1] >  PBC_vec[1][1]/2 ) dr[1] -= PBC_vec[1][1]; 
								while( dr[2] >  PBC_vec[2][2]/2 ) dr[2] -= PBC_vec[2][2];
		
								double dist = normalize(dr);
		
								if( dist < ion_cutoff)
									bad_res = 1; 
							}
							if( bad_res ) break;
						}
		
						if( !bad_res )
						{
							// is the point inside or outside?

							int f;
							double u, v;
							double distance;
				
							nearPointOnBoxedSurface( rp, &f, &u, &v, M, mlow, mhigh, &distance, 0 );	
							double nearp[3], nearn[3];
				                	evaluateRNRM( f, u, v, nearp, nearn, rsurf );
				
							double dr[3] = { rp[0] - nearp[0], rp[1] - nearp[1], rp[2] - nearp[2] };
							wrapPBC( dr, rsurf+3*nv );
					
							int io = dr[0] * nearn[0] + dr[1] * nearn[1] + dr[2] * nearn[2];
				
							if( io > 0 && leaflet == 0 )
								done = 0;
							else if( io < 0 && leaflet == 1 )
								done = 0;
							else	
								done = 1;
						}
					}
				
					fprintf(charmmFile, "coor set xdir %lf ydir %lf zdir %lf select resid %d end\n",
						rp[0], rp[1], rp[2], res );
					res++;
				}
			}
			
			if( pass == 0 )
			{
				if( nK[0] + nK[1] > 0 )
				{
					fprintf(charmmFile, "write psf card name pot.psf\n");
					fprintf(charmmFile, "write coor card name pot.crd\n");
					fprintf(charmmFile, "delete atom sele atom * * * end\n");
				}
			}	
			else
			{
				if( nCl[0] + nCl[1] > 0 )
				{
					fprintf(charmmFile, "write psf card name cla.psf\n");
					fprintf(charmmFile, "write coor card name cla.crd\n");
					fprintf(charmmFile, "delete atom sele atom * * * end\n");
				}
			}
		}
		wrote_salt = 1;	
	}

	int wrote_psf = 0;

	for( int p = 0; p < npairs; p++ )
	{
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", pairs[p].PSFfileName );

		if( !wrote_psf )
		{
			fprintf(charmmFile, "read psf card unit 10\n" );	
			wrote_psf = 1;
		}
		else
			fprintf(charmmFile, "read psf card append unit 10\n" );	
		fprintf(charmmFile, "close unit 10\n" );	
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", pairs[p].CRDfileName );	
		fprintf(charmmFile, "read coor card unit 10 resid\n" );	
		fprintf(charmmFile, "close unit 10\n" );
		fprintf(charmmFile, "\n");	
		
	}

	if( wrote_water_psf )
	{
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", waterPSFName );
		if( !wrote_psf )
		{
			fprintf(charmmFile, "read psf card unit 10\n" );	
			wrote_psf = 1;
		}
		else
			fprintf(charmmFile, "read psf card append unit 10\n" );	
		fprintf(charmmFile, "close unit 10\n" );	
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", waterFileName );	
		fprintf(charmmFile, "read coor card unit 10 append\n" );
		fprintf(charmmFile, "close unit 10\n" );
		fprintf(charmmFile, "\n");	
			
	}

	if( loadProtein )
	{
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", proteinPSFName );
		if( !wrote_psf )
		{
			fprintf(charmmFile, "read psf card unit 10\n" );	
			wrote_psf = 1;
		}
		else
			fprintf(charmmFile, "read psf card append unit 10\n" );	
		fprintf(charmmFile, "close unit 10\n" );	
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", proteinCRDName );	
		if( proteinIsCRD )
			fprintf(charmmFile, "read coor card unit 10 resid\n" );
		else
			fprintf(charmmFile, "read coor pdb unit 10 resid\n" );
	
		fprintf(charmmFile, "close unit 10\n" );
		fprintf(charmmFile, "\n");	
	}

	if( wrote_salt )
	{
		if( nK[0] + nK[1] >0)
		{
			fprintf(charmmFile, "open unit 10 card read name pot.psf\n");
			if( !wrote_psf )
			{
				fprintf(charmmFile, "read psf card unit 10\n" );	
				wrote_psf = 1;
			}
			else
				fprintf(charmmFile, "read psf card append unit 10\n" );	
			fprintf(charmmFile, "close unit 10\n" );	
			fprintf(charmmFile, "open unit 10 card read name pot.crd\n" );	
			fprintf(charmmFile, "read coor card unit 10 resid\n" );
			fprintf(charmmFile, "close unit 10\n" );
			fprintf(charmmFile, "\n");	
		}

		if( nCl[0] + nCl[1] > 0 )
		{
			fprintf(charmmFile, "open unit 10 card read name cla.psf\n");
			if( !wrote_psf )
			{
				fprintf(charmmFile, "read psf card unit 10\n" );	
				wrote_psf = 1;
			}
			else
				fprintf(charmmFile, "read psf card append unit 10\n" );	
			fprintf(charmmFile, "close unit 10\n" );	
			fprintf(charmmFile, "open unit 10 card read name cla.crd\n" );	
			fprintf(charmmFile, "read coor card unit 10 resid\n" );
			fprintf(charmmFile, "close unit 10\n" );
			fprintf(charmmFile, "\n");	
		}
	}
	fprintf(charmmFile, "%s", charmm_footer );

	free(regions_for_face);
	free(tri_list);
	free(rsurf);
	
	// free up boxing info	
	for( int b = 0; b < nx*ny*nz; b++ )
		free(theBoxes[b].plist);
	free(theBoxes);
	fclose(doubleBondIndexes);		
}

// getCoordinateSystem
// 
// We need to have a coordinate system that is transported smoothly from one central location
// We also want to have a robust representation of a lipid far from that location
// These are somewhat incompatible on a complicated surface: the coordinate system becomes non-orthogonal and may have a very different metric.
// This function gets x and y from the principal curvatures at one face
// it smoothly transports the x coordinate onto the new point
// y is then determined by orthogonality with the normal
// this determines the xyz coordinate system mapping at the distance point where the lipid can be reconstructed.
int surface::getCoordinateSystem( int source_f,   double *source_u,  double *source_v, 
//				  int distance_f, double distant_u, double distant_v, 
				  double dr[3], double strain, int leaflet,
				  double *dx_duv, double *dy_duv, double *rsurf, int *regional_face, int *ncrosses )
{
	double drdu[3]={0,0,0}, drdv[3]={0,0,0};	
	double u_cen = *source_u;
	double v_cen = *source_v;

	double transp_cen[3]={0,0,0}, transp_nrm[3]={0,0,1};

	if( source_f >= nf_faces )	
	{
//		printf("Using irregular vertex.\n");
	}

	evaluateRNRM( source_f, u_cen, v_cen, transp_cen, transp_nrm, rsurf ); 

	ru( source_f, u_cen, v_cen,  rsurf, drdu ); 
	rv( source_f, u_cen, v_cen,  rsurf, drdv ); 

	double lru = sqrt(drdu[0]*drdu[0]+drdu[1]*drdu[1]+drdu[2]*drdu[2]);
	double lrv = sqrt(drdv[0]*drdv[0]+drdv[1]*drdv[1]+drdv[2]*drdv[2]);
	
	double dp = (drdu[0]*drdv[0] + drdu[1]*drdv[1] + drdu[2]*drdv[2]);
	
	// drdu and o_drdv are orthonormal unit vectors.
	// they are paired with coordinates up and vp.
	
	double o_drdu[3] = { drdu[0] / lru, drdu[1] / lru, drdu[2] / lru };
	double o_drdv[3] = { drdv[0] / lrv - o_drdu[0]*dp/lru/lrv, 
		             drdv[1] / lrv - o_drdu[1]*dp/lru/lrv, 
		             drdv[2] / lrv - o_drdu[2]*dp/lru/lrv };
	double lscale = normalize(o_drdv);

	// solve u drdu + v drdv == up o_drdu + vp o_drdv in general:
	
	double tr_22 = (o_drdv[0] * o_drdv[0] + o_drdv[1] * o_drdv[1] + o_drdv[2] * o_drdv[2])/(o_drdv[0] * drdv[0] + o_drdv[1] * drdv[1] + o_drdv[2] * drdv[2]);
	
	// this is the transform from up,vp to u, v.
	
	double transform[4] = { 
		1 / (lru),	-tr_22 * dp/(lru*lru),
		0,		tr_22 
	};
	
	// get curvature information

	double c1=0, c2=0;
	double cvec1[2], cvec2[2];

	double k;
	double ctot = c(source_f,u_cen,v_cen,rsurf,&k,cvec1,cvec2,&c1,&c2);

	// use the cvec1 and cvec2 as the x/y coordinate system.

	double vec_c1[3] = { cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
			     cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
			     cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
	double vec_c2[3] = { cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
			     cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
			     cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };
	
	double vdp  = vec_c1[0] * vec_c2[0] + vec_c1[1] * vec_c2[1] + vec_c1[2] * vec_c2[2];
	double lv1 = normalize(vec_c1);
	double lv2 = normalize(vec_c2);

	double crp[3];
	cross( vec_c1, vec_c2, crp);
	double dp_sign = crp[0] * transp_nrm[0] + crp[1] * transp_nrm[1] + crp[2] * transp_nrm[2];

	double dx[2] = { cvec1[0], cvec1[1] }; 
	
	double dc1 = dr[0] / lv1;
	double dc2 = dr[1] / lv2;
	double du=0,dv=0;
	double z_scaled = dr[2];	
	
	double use_PP = exp(strain)*PP;
	
	if( leaflet == 1 )
	{
		// these are scalings needed for displacement at the bilayer midplane to get the proper distances at the neutral surface (PP)
//		double scale1 = (1- c1 * (use_PP-dr[2]))/(1+c1*use_PP);
//		double scale2 = (1- c2 * (use_PP-dr[2]))/(1+c2*use_PP);
//		double scale1 = 1./(1+c1*use_PP);
//		double scale2 = 1./(1+c2*use_PP);

		double scale1 = mod_exp(-use_PP * c1);
		double scale2 = mod_exp(-use_PP * c2);

		// if scale1 is less than 1, it means that the z length has shrunk (the x dimension is larger at the midplane and so the particle's midplane displacement must be scaled down).

		double lat_scale = scale1*scale2;

		dc1 *= scale1;
		dc2 *= scale2;

		double z =dr[2]*exp(strain);
		double scale = (1+c1*use_PP) * (1+c2*use_PP);
		z_scaled = scale * use_PP - (use_PP -z) * (1+(use_PP-z)*c1)*(1+(use_PP-z)*c2);
	
		du = cvec1[0] * dc1 + cvec2[0] * dc2; 
		dv = cvec1[1] * dc1 + cvec2[1] * dc2; 
	}
	else
	{
		//double scale1 = (1+ c1 * (-use_PP-dr[2]))/(1-c1*(-use_PP));
		//double scale2 = (1+ c2 * (-use_PP-dr[2]))/(1-c2*(-use_PP));
//		double scale1 = 1./(1-c1*use_PP);
//		double scale2 = 1./(1-c2*use_PP);
		double scale1 = mod_exp(use_PP * c1);
		double scale2 = mod_exp(use_PP * c2);

		double lat_scale = scale1*scale2;
		dc1 *= scale1;
		dc2 *= scale2;
		//z_scaled = dr[2] * (1+c1*dr[2]) * (1+c2*dr[2]);
		double z =dr[2]*exp(strain);
		double scale = (1-c1*use_PP) * (1-c2*use_PP);
		//z_scaled = -scale * use_PP - (-use_PP -z) * scale1 * scale2;
		z_scaled = -scale * use_PP - (-use_PP -z) * (1-(-use_PP-z)*c1)*(1-(-use_PP-z)*c2);
	
		du = cvec1[0] * dc1 + cvec2[0] * dc2; 
		dv = cvec1[1] * dc1 + cvec2[1] * dc2; 
	}


	int done = 0;

	int fp = source_f;

	while( ! done )
	{
		int f_pre = source_f;
		double upre = u_cen;
		double vpre = v_cen;
		double du_pre = du;
		double dv_pre = dv;

		int f2 = nextFace( fp, &u_cen, &v_cen, &du, &dv, rsurf, dx );	

		if( regional_face[f2] == 0 )
			(*ncrosses)++;

		if( f2 == fp ) 
			done = 1;

		fp = f2;
	}

	// dx is the smoothly transported x coordinate.

	// the new drdu/drdv
	ru( fp, u_cen, v_cen,  rsurf, drdu ); 
	rv( fp, u_cen, v_cen,  rsurf, drdv ); 

	double vec_x[3] = { drdu[0] * dx[0] + drdv[0] * dx[1],
			    drdu[1] * dx[0] + drdv[1] * dx[1],
			    drdu[2] * dx[0] + drdv[2] * dx[1] };
	double lv = normalize(vec_x);

	// dx is now unit system.
	dx[0] /= lv;
	dx[1] /= lv;

	double RuRu = drdu[0]*drdu[0]+drdu[1]*drdu[1]+drdu[2]*drdu[2];
	double RuRv = drdu[0]*drdv[0]+drdu[1]*drdv[1]+drdu[2]*drdv[2];
	double RvRv = drdv[0]*drdv[0]+drdv[1]*drdv[1]+drdv[2]*drdv[2];

	double xu = dx[0];
	double xv = dx[1];
	double yu = 1;
	double yv = (-RuRu * xu * yu - RuRv * xv * yu) / (RuRv * xu + RvRv * xv);
	
	double dy[2] = { yu, yv };
	double vec_y[3] = { drdu[0] * dy[0] + drdv[0] * dy[1],
			    drdu[1] * dy[0] + drdv[1] * dy[1],
			    drdu[2] * dy[0] + drdv[2] * dy[1] };
	lv = normalize(vec_y);

	dy[0] /= lv;
	dy[1] /= lv;

	double final_cen[3];
	double final_nrm[3];

	evaluateRNRM( fp, u_cen, v_cen, final_cen, final_nrm, rsurf ); 
	
	double fcrp[3];
	cross( vec_x, vec_y, fcrp );

	double dp_final = fcrp[0] * final_nrm[0] + fcrp[1] * final_nrm[1] + fcrp[2] * final_nrm[2];

	if( dp_final * dp_sign < 0 )
	{
		dy[0] *= -1;
		dy[1] *= -1;
	}

	dx_duv[0] = dx[0];
	dx_duv[1] = dx[1];

	dy_duv[0] = dy[0];
	dy_duv[1] = dy[1];

	*source_u = u_cen;
	*source_v = v_cen;

	// vec_x = dx[0] * drdu + dx[1] * drdv
	// vec_y is perpendicular 
	return fp;
	

	// x is now d

/*
	// this is u-prime and v-prime:	

	double up = dr[0];
	double vp = dr[1];

	// up uvec = uvec up 

	double du = up * transform[0] + vp * transform[1];
	double dv = up * transform[2] + vp * transform[3];
*/

	
}


int surface::simple_evaluate_at( double eval[3], double dr[3], int f, double *u, double *v, double *rsurf, int leaflet, double strain, double *dx_duv, double *dy_duv, double w_use, double w_rim, double *rimp, double *rimn)
{
	double drdu[3]={0,0,0}, drdv[3]={0,0,0};
	
	double u_cen = *u;
	double v_cen = *v;

	double transp_cen[3]={0,0,0}, transp_nrm[3]={0,0,1};

	if( f >= nf_faces )	
	{
//		printf("Using irregular vertex.\n");
	}

	evaluateRNRM( f, u_cen, v_cen, transp_cen, transp_nrm, rsurf ); 

	double eval_in[3] = { 
		transp_cen[0] + transp_nrm[0] * dr[2]*exp(strain), 
		transp_cen[1] + transp_nrm[1] * dr[2]*exp(strain), 
		transp_cen[2] + transp_nrm[2] * dr[2]*exp(strain) 
		};
	ru( f, u_cen, v_cen,  rsurf, drdu ); 
	rv( f, u_cen, v_cen,  rsurf, drdv ); 
	double lru = sqrt(drdu[0]*drdu[0]+drdu[1]*drdu[1]+drdu[2]*drdu[2]);
	double lrv = sqrt(drdv[0]*drdv[0]+drdv[1]*drdv[1]+drdv[2]*drdv[2]);
	
	double dp = (drdu[0]*drdv[0] + drdu[1]*drdv[1] + drdu[2]*drdv[2]);
	
	// drdu and o_drdv are orthonormal unit vectors.
	// they are paired with coordinates up and vp.
	
	double o_drdu[3] = { drdu[0] / lru, drdu[1] / lru, drdu[2] / lru };
	double o_drdv[3] = { drdv[0] / lrv - o_drdu[0]*dp/lru/lrv, 
		             drdv[1] / lrv - o_drdu[1]*dp/lru/lrv, 
		             drdv[2] / lrv - o_drdu[2]*dp/lru/lrv };
	double lscale = normalize(o_drdv);

	// solve u drdu + v drdv == up o_drdu + vp o_drdv in general:
	
	double tr_22 = (o_drdv[0] * o_drdv[0] + o_drdv[1] * o_drdv[1] + o_drdv[2] * o_drdv[2])/(o_drdv[0] * drdv[0] + o_drdv[1] * drdv[1] + o_drdv[2] * drdv[2]);
	
	// this is the transform from up,vp to u, v.
	
	double transform[4] = { 
		1 / (lru),	-tr_22 * dp/(lru*lru),
		0,		tr_22 
	};
	
	// get curvature information

	double c1=0, c2=0;
	double cvec1[2], cvec2[2];

	double k;
	double ctot = c(f,u_cen,v_cen,rsurf,&k,cvec1,cvec2,&c1,&c2);


	// use the cvec1 and cvec2 as the x/y coordinate system.

	double vec_c1[3] = { cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
			     cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
			     cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
	double vec_c2[3] = { cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
			     cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
			     cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };
	
	double vdp  = vec_c1[0] * vec_c2[0] + vec_c1[1] * vec_c2[1] + vec_c1[2] * vec_c2[2];
	double lv1 = normalize(vec_c1);
	double lv2 = normalize(vec_c2);

	if( dx_duv && dy_duv )
	{
		// replace with these vectors.
	
		cvec1[0] = dx_duv[0];
		cvec1[1] = dx_duv[1];
	
		cvec2[0] = dy_duv[0];
		cvec2[1] = dy_duv[1];

		double old_c1 = c1;
		double old_c2 = c2;

		double new_vec_c1[3] = {  cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
			   		  cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
			   		  cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
		
		double new_vec_c2[3] = {  cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
			   		  cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
			   		  cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };

		double l1n = normalize(new_vec_c1);
		double l1o = normalize(vec_c1);
		double l2n = normalize(new_vec_c2);
		double l2o = normalize(vec_c2);

		double dp11 = new_vec_c1[0] * vec_c1[0] + new_vec_c1[1] * vec_c1[1] + new_vec_c1[2] * vec_c1[2];
		double dp12 = new_vec_c1[0] * vec_c2[0] + new_vec_c1[1] * vec_c2[1] + new_vec_c1[2] * vec_c2[2];
		double dp21 = new_vec_c2[0] * vec_c1[0] + new_vec_c2[1] * vec_c1[1] + new_vec_c2[2] * vec_c1[2];
		double dp22 = new_vec_c2[0] * vec_c2[0] + new_vec_c2[1] * vec_c2[1] + new_vec_c2[2] * vec_c2[2];

		c1 = old_c1 * dp11*dp11 + old_c2 * dp12 * dp12;
		c2 = old_c1 * dp21*dp21 + old_c2 * dp22 * dp22;

//		c1 = dp11 * old_c1/l1n/l1o + dp12 * old_c2/l1n/l2o;
//		c2 = dp21 * old_c1/l2n/l1o + dp22 * old_c2/l2n/l2o;

		lv1 = l1n;
		lv2 = l2n;	
	}


/*
	// this is u-prime and v-prime:	

	double up = dr[0];
	double vp = dr[1];

	// up uvec = uvec up 

	double du = up * transform[0] + vp * transform[1];
	double dv = up * transform[2] + vp * transform[3];
*/

	// only modification is z?

	double total_c = c1+c2;

	double dc1 = dr[0] / lv1;
	double dc2 = dr[1] / lv2;
	double du=0,dv=0;
	double z_scaled = dr[2];	

	double x_dir[3] = { 
		cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
		cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
		cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
	
	double y_dir[3] = { 
		cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
		cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
		cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };
	
/*
	if( f == nf_faces )
	{
		printf("x: %le %le %le ", x_dir[0], x_dir[1], x_dir[2] );
		printf("y: %le %le %le\n", y_dir[0], y_dir[1], y_dir[2] );
	}
*/
	double use_PP = exp(strain)*PP;

	double lat_scale = 1.0;

	if( total_c < -0.03 ) total_c = -0.03;
	if( total_c >  0.03 ) total_c = 0.03;

	if( leaflet == 1 )
	{
		// these are scalings needed for displacement at the bilayer midplane to get the proper distances at the neutral surface (PP)
		//lat_scale =  (1- total_c * (use_PP-dr[2]))/(1+total_c*use_PP);
//		lat_scale = mod_exp( -total_c * (use_PP-dr[2]) ); // z  is zero leads to contraction of the outer leaflet, pos curv
		
		double z = dr[2];
		lat_scale = mod_exp( -total_c * (use_PP-z) );
		z_scaled = z * mod_exp( -total_c * (z/2-use_PP) );
	}
	else
	{
		// these are scalings needed for displacement at the bilayer midplane to get the proper distances at the neutral surface (PP)
		//lat_scale =  (1+ total_c * (use_PP+dr[2]))/(1-total_c*use_PP);
		double z = dr[2];
		lat_scale = mod_exp( total_c * (use_PP-z) );
		z_scaled = z * mod_exp( -total_c * (z/2+use_PP) );
	}

	if( rimp && w_use < 1.0 )
	{
		double usen[3] = { 
//			np[0] * w_use + rimn[0] * w_rim,
//			np[1] * w_use + rimn[1] * w_rim,
//			np[2] * w_use + rimn[2] * w_rim	
			transp_nrm[0], transp_nrm[1], transp_nrm[2] };
		normalize(usen);
		eval[0] = transp_cen[0]+rimp[0] + usen[0] * z_scaled + (x_dir[0] * dr[0] + y_dir[0] * dr[1])*lat_scale; 
		eval[1] = transp_cen[1]+rimp[1] + usen[1] * z_scaled + (x_dir[1] * dr[0] + y_dir[1] * dr[1])*lat_scale; 
		eval[2] = transp_cen[2]+rimp[2] + usen[2] * z_scaled + (x_dir[2] * dr[0] + y_dir[2] * dr[1])*lat_scale; 
	}
	else
	{
		eval[0] = transp_cen[0] + transp_nrm[0] * z_scaled + (x_dir[0] * dr[0] + y_dir[0] * dr[1])*lat_scale; 
		eval[1] = transp_cen[1] + transp_nrm[1] * z_scaled + (x_dir[1] * dr[0] + y_dir[1] * dr[1])*lat_scale; 
		eval[2] = transp_cen[2] + transp_nrm[2] * z_scaled + (x_dir[2] * dr[0] + y_dir[2] * dr[1])*lat_scale; 
	}

	double dr_out[3] = { eval[0] - eval_in[0], eval[1] - eval_in[1], eval[2] - eval_in[2] };
	double rout = normalize(dr_out);
	double rin = sqrt(dr[0]*dr[0]+dr[1]*dr[1]);

//	printf("%lf c1: %lf c2: %lf out_len %lf orig len %lf\n", dr[2], c1, c2, rout, rin); 					

	*u = u_cen;
	*v = v_cen;

	return f;
}

int surface::evaluate_at( double eval[3], double dr[3], int f, double *u, double *v, double *rsurf, int leaflet, double strain, double *dx_duv, double *dy_duv, double w_use, double w_rim, double *rimp, double *rimn)
{
	double drdu[3]={0,0,0}, drdv[3]={0,0,0};
	
	double u_cen = *u;
	double v_cen = *v;

	double transp_cen[3]={0,0,0}, transp_nrm[3]={0,0,1};

	if( f >= nf_faces )	
	{
//		printf("Using irregular vertex.\n");
	}

	evaluateRNRM( f, u_cen, v_cen, transp_cen, transp_nrm, rsurf ); 

	double eval_in[3] = { 
		transp_cen[0] + transp_nrm[0] * dr[2]*exp(strain), 
		transp_cen[1] + transp_nrm[1] * dr[2]*exp(strain), 
		transp_cen[2] + transp_nrm[2] * dr[2]*exp(strain) 
		};
	ru( f, u_cen, v_cen,  rsurf, drdu ); 
	rv( f, u_cen, v_cen,  rsurf, drdv ); 
	double lru = sqrt(drdu[0]*drdu[0]+drdu[1]*drdu[1]+drdu[2]*drdu[2]);
	double lrv = sqrt(drdv[0]*drdv[0]+drdv[1]*drdv[1]+drdv[2]*drdv[2]);
	
	double dp = (drdu[0]*drdv[0] + drdu[1]*drdv[1] + drdu[2]*drdv[2]);
	
	// drdu and o_drdv are orthonormal unit vectors.
	// they are paired with coordinates up and vp.
	
	double o_drdu[3] = { drdu[0] / lru, drdu[1] / lru, drdu[2] / lru };
	double o_drdv[3] = { drdv[0] / lrv - o_drdu[0]*dp/lru/lrv, 
		             drdv[1] / lrv - o_drdu[1]*dp/lru/lrv, 
		             drdv[2] / lrv - o_drdu[2]*dp/lru/lrv };
	double lscale = normalize(o_drdv);

	// solve u drdu + v drdv == up o_drdu + vp o_drdv in general:
	
	double tr_22 = (o_drdv[0] * o_drdv[0] + o_drdv[1] * o_drdv[1] + o_drdv[2] * o_drdv[2])/(o_drdv[0] * drdv[0] + o_drdv[1] * drdv[1] + o_drdv[2] * drdv[2]);
	
	// this is the transform from up,vp to u, v.
	
	double transform[4] = { 
		1 / (lru),	-tr_22 * dp/(lru*lru),
		0,		tr_22 
	};
	
	// get curvature information

	double c1=0, c2=0;
	double cvec1[2], cvec2[2];

	double k;
	double ctot = c(f,u_cen,v_cen,rsurf,&k,cvec1,cvec2,&c1,&c2);

	// use the cvec1 and cvec2 as the x/y coordinate system.

	double vec_c1[3] = { cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
			     cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
			     cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
	double vec_c2[3] = { cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
			     cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
			     cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };
	
	double vdp  = vec_c1[0] * vec_c2[0] + vec_c1[1] * vec_c2[1] + vec_c1[2] * vec_c2[2];
	double lv1 = normalize(vec_c1);
	double lv2 = normalize(vec_c2);

	if( dx_duv && dy_duv )
	{
		// replace with these vectors.
	
		cvec1[0] = dx_duv[0];
		cvec1[1] = dx_duv[1];
	
		cvec2[0] = dy_duv[0];
		cvec2[1] = dy_duv[1];

		double old_c1 = c1;
		double old_c2 = c2;

		double new_vec_c1[3] = {  cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
			   		  cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
			   		  cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
		
		double new_vec_c2[3] = {  cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
			   		  cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
			   		  cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };
		double dp11 = new_vec_c1[0] * vec_c1[0] + new_vec_c1[1] * vec_c1[1] + new_vec_c1[2] * vec_c1[2];
		double dp12 = new_vec_c1[0] * vec_c2[0] + new_vec_c1[1] * vec_c2[1] + new_vec_c1[2] * vec_c2[2];
		double dp21 = new_vec_c2[0] * vec_c1[0] + new_vec_c2[1] * vec_c1[1] + new_vec_c2[2] * vec_c1[2];
		double dp22 = new_vec_c2[0] * vec_c2[0] + new_vec_c2[1] * vec_c2[1] + new_vec_c2[2] * vec_c2[2];

		double l1n = normalize(new_vec_c1);
		double l1o = normalize(vec_c1);
		double l2n = normalize(new_vec_c2);
		double l2o = normalize(vec_c2);

		c1 = dp11 * old_c1/l1n/l1o + dp12 * old_c2/l1n/l2o;
		c2 = dp21 * old_c1/l2n/l1o + dp22 * old_c2/l2n/l2o;

		lv1 = l1n;
		lv2 = l2n;	
	}


/*
	// this is u-prime and v-prime:	

	double up = dr[0];
	double vp = dr[1];

	// up uvec = uvec up 

	double du = up * transform[0] + vp * transform[1];
	double dv = up * transform[2] + vp * transform[3];
*/

	double dc1 = dr[0] / lv1;
	double dc2 = dr[1] / lv2;
	double du=0,dv=0;
	double z_scaled = dr[2];	

	if( leaflet == 1 && fabs(dr[2]-PP) < 1 )
	{
	}

	if( debug_on && leaflet == 1 )
	{
		printf("z: %lf PP: %lf\n", dr[2], PP );
	}

	double use_PP = exp(strain)*PP;

	if( leaflet == 1 )
	{
//		double scale1 =  (1 + c1 * (PP-dr[2]));
//		double scale2 =  (1 + c2 * (PP-dr[2]));

		// these are scalings needed for displacement at the bilayer midplane to get the proper distances at the neutral surface (PP)
		double scale1 = (1- c1 * (use_PP-dr[2]))/(1+c1*use_PP);
		double scale2 = (1- c2 * (use_PP-dr[2]))/(1+c2*use_PP);

		// if scale1 is less than 1, it means that the z length has shrunk (the x dimension is larger at the midplane and so the particle's midplane displacement must be scaled down).



		double lat_scale = scale1*scale2;

		dc1 *= scale1;
		dc2 *= scale2;

		double z =dr[2]*exp(strain);
		double scale = (1+c1*use_PP) * (1+c2*use_PP);
		z_scaled = scale * use_PP - (use_PP -z) * (1+(use_PP-z)*c1)*(1+(use_PP-z)*c2);
	
		du = cvec1[0] * dc1 + cvec2[0] * dc2; 
		dv = cvec1[1] * dc1 + cvec2[1] * dc2; 
	}
	else
	{
		//double scale1= (1 - c1 * (-use_PP-dr[2]));
		//double scale2= (1 - c2 * (-use_PP-dr[2]));
		double scale1 = (1+ c1 * (-use_PP-dr[2]))/(1-c1*(-use_PP));
		double scale2 = (1+ c2 * (-use_PP-dr[2]))/(1-c2*(-use_PP));
		

		double lat_scale = scale1*scale2;
		dc1 *= scale1;
		dc2 *= scale2;
		//z_scaled = dr[2] * (1+c1*dr[2]) * (1+c2*dr[2]);
		double z =dr[2]*exp(strain);
		double scale = (1-c1*use_PP) * (1-c2*use_PP);
		//z_scaled = -scale * use_PP - (-use_PP -z) * scale1 * scale2;
		z_scaled = -scale * use_PP - (-use_PP -z) * (1-(-use_PP-z)*c1)*(1-(-use_PP-z)*c2);
	
		du = cvec1[0] * dc1 + cvec2[0] * dc2; 
		dv = cvec1[1] * dc1 + cvec2[1] * dc2; 

	}

	int f_orig = f;
	double du_orig = du;
	double dv_orig =dv;
	double ucen_orig = u_cen;
	double vcen_orig = v_cen;

	int fp = f;
	int done = 0;

	double rp[3] = { transp_cen[0], transp_cen[1], transp_cen[2] };
	double np[3] = { transp_nrm[0], transp_nrm[1], transp_nrm[2] };
	int eval_trip = 0;

	while( ! done )
	{
		int f_pre = fp;
		double upre = u_cen;
		double vpre = v_cen;
		double du_pre = du;
		double dv_pre = dv;

		int f2 = nextFace( fp, &u_cen, &v_cen, &du, &dv, rsurf );	

		if( f2 >= nf_faces && !eval_trip )
		{
			//we moved onto an irregular vertex, use the approximation.
			
			double app_ru[3], app_rv[3];
			ru( f_pre, upre, vpre,  rsurf, app_ru ); 
			rv( f_pre, upre, vpre,  rsurf, app_rv );
			evaluateRNRM( f_pre, upre, vpre, rp, np, rsurf );

			rp[0] += app_ru[0] * du_pre + app_rv[0] * dv_pre; 
			rp[1] += app_ru[1] * du_pre + app_rv[1] * dv_pre; 
			rp[2] += app_ru[2] * du_pre + app_rv[2] * dv_pre; 

			eval_trip = 1;
		}

		if( f2 == fp ) 
		{
			if( ! eval_trip )
				evaluateRNRM( fp, u_cen, v_cen, rp, np, rsurf ); 
			done = 1;
		}

		fp = f2;
	}	

//	if( debug_on )
//		printf("leaflet: %d dr: %le %le %le c: %le %le f_orig: %d uorig: %le vorig: %le du: %le dv: %le eval at %d %le %le\n", leaflet, dr[0], dr[1], dr[2], c1, c2, ucen_orig, vcen_orig, f_orig, du_orig, dv_orig, fp, u_cen, v_cen  );
	

	if( debug_on && leaflet == 1 )
	{
		printf("eval_z: %lf use_PP: %lf\n", z_scaled, use_PP );
	}

	if( rimp && w_use < 1.0 )
	{
		double usen[3] = { 
//			np[0] * w_use + rimn[0] * w_rim,
//			np[1] * w_use + rimn[1] * w_rim,
//			np[2] * w_use + rimn[2] * w_rim	
			np[0], np[1], np[2] };
		normalize(usen);
		eval[0] = rp[0]+rimp[0] + usen[0] * z_scaled; 
		eval[1] = rp[1]+rimp[1] + usen[1] * z_scaled; 
		eval[2] = rp[2]+rimp[2] + usen[2] * z_scaled; 
	}
	else
	{
		eval[0] = rp[0] + np[0] * z_scaled; 
		eval[1] = rp[1] + np[1] * z_scaled; 
		eval[2] = rp[2] + np[2] * z_scaled; 
	}

	double dr_out[3] = { eval[0] - eval_in[0], eval[1] - eval_in[1], eval[2] - eval_in[2] };
	double rout = normalize(dr_out);
	double rin = sqrt(dr[0]*dr[0]+dr[1]*dr[1]);

//	printf("%lf c1: %lf c2: %lf out_len %lf orig len %lf\n", dr[2], c1, c2, rout, rin); 					

	*u = u_cen;
	*v = v_cen;

	return fp;
}


static surface *rim_min_surface = NULL;
static double *rim_min_rsurf = NULL;

static int *rim_min_f = NULL;
static double *rim_min_uv_start = NULL;

static int *rim_min_f_reset = NULL;
static double *rim_min_uv_start_reset = NULL;

static int rim_min_npts = 0;
static double *output_rim_triangles = NULL;

static FILE *rim_min_traj = NULL;

double rim_min_en( double *p )
{
	double *rp = (double *)malloc( sizeof(double) * 3 * rim_min_npts );

	for( int i = 0; i < rim_min_npts; i++ )
	{
		int f_start = rim_min_f[i];
		double u_start = rim_min_uv_start[2*i+0];
		double v_start = rim_min_uv_start[2*i+1];
		
		double duv[2] = { p[1+2*i+0], p[1+2*i+1] };


		int test_f = f_start;
		int f2 = f_start;

		do {
			test_f = f2;
			f2 = rim_min_surface->nextFace( test_f, &u_start, &v_start, duv, duv+1, rim_min_rsurf );	
		} while( f2 != test_f );

		rim_min_f_reset[i] = f2;
		rim_min_uv_start_reset[2*i+0] = u_start;
		rim_min_uv_start_reset[2*i+1] = v_start;

		double orp[3], np[3];
		rim_min_surface->evaluateRNRM( f2, u_start, v_start, orp, np, rim_min_rsurf );

		rp[3*i+0] = orp[0];	
		rp[3*i+1] = orp[1];	
		rp[3*i+2] = orp[2];	
	}

	double chi2 = 0;
	for( int i = 0; i < rim_min_npts; i++ )
	{
		int ip1 = i+1;
		if( ip1 >= rim_min_npts ) ip1 -= rim_min_npts;
		double dr[3] = { 
			rp[3*i+0] - rp[3*ip1+0],
			rp[3*i+1] - rp[3*ip1+1],
			rp[3*i+2] - rp[3*ip1+2] };

		chi2 += dr[0]*dr[0]+dr[1]*dr[1]+dr[2]*dr[2];
	}

#define DEBUG_RIM

	static int cntr=0;
	static int period = 100;

#ifdef DEBUG_RIM
	if( cntr % period == 0 && rim_min_traj)
	{
		fprintf(rim_min_traj,"%d\n", rim_min_npts );
		fprintf(rim_min_traj,"rim minimization\n");
		for( int i = 0; i < rim_min_npts; i++ )
			fprintf(rim_min_traj,"O %lf %lf %lf\n", rp[3*i+0], rp[3*i+1], rp[3*i+2] );
		fflush(rim_min_traj);
	}

	cntr++;
#endif

	if( output_rim_triangles )
	{
		double com[3] = {0,0,0};
		for( int i = 0; i < rim_min_npts; i++ )
		{
			com[0] += rp[3*i+0];
			com[1] += rp[3*i+1];
			com[2] += rp[3*i+2];
		}

		com[0] /= rim_min_npts;
		com[1] /= rim_min_npts;
		com[2] /= rim_min_npts;

				
		for( int i = 0; i < rim_min_npts; i++ )
		{
			int ip1 = i+1;
			if( ip1 >= rim_min_npts )
				ip1 -= rim_min_npts;

			output_rim_triangles[3*3*i+0] = rp[3*i+0];
			output_rim_triangles[3*3*i+1] = rp[3*i+1];
			output_rim_triangles[3*3*i+2] = rp[3*i+2];
			
			output_rim_triangles[3*3*i+3] = rp[3*ip1+0];
			output_rim_triangles[3*3*i+4] = rp[3*ip1+1];
			output_rim_triangles[3*3*i+5] = rp[3*ip1+2];
			
			// the third point in the triangle must be the center
			// if this is changed, the logic of how to calculate the rim extent must be changed above.
			
			output_rim_triangles[3*3*i+6] = com[0];
			output_rim_triangles[3*3*i+7] = com[1];
			output_rim_triangles[3*3*i+8] = com[2];

		}
	}	

	free(rp);

//	printf("chi2: %le\n", chi2 );

	return chi2;
}

	
void EndSegment( FILE *charmmFile, char *cur_filename, char *cur_segment, char *cur_segname, crd_psf_pair **pairs, int *seg_cntr, int *npairs, int *npair_space, int x_leaflet,
	int *cur_size, int *cur_natoms, int *cur_atom, int *cur_res, int *switched, int gm1_switch )
{	
	const char *out_in[3]= {"IN","OUT", "RIM"};

        fprintf(charmmFile, 
        "\n" 
        "open read card unit 10 name \"%s\"\n"
        "read sequence coor card unit 10\n"
        "generate %s setup warn first none last none\n"
        "open read unit 10 card name \"%s\"\n"
        "read coor unit 10 card resid\n", cur_filename, cur_segname, cur_filename );
     
        if( gm1_switch )
        {    
                fprintf(charmmFile, "patch CERB %s %d %s %d setup warn\n", cur_segname, 2, cur_segname, 1 ); 
                fprintf(charmmFile, "patch 14BB %s %d %s %d setup warn\n",  cur_segname,2,  cur_segname,3 );
                fprintf(charmmFile, "patch 14BA %s %d %s %d setup warn\n",  cur_segname,3,  cur_segname,4 );
                fprintf(charmmFile, "patch 13BB %s %d %s %d setup warn\n",  cur_segname,4,  cur_segname,5 );
                fprintf(charmmFile, "patch SA23AB %s %d %s %d setup warn\n",  cur_segname,3,  cur_segname,6 );
        }    

        fprintf(charmmFile,     "\n" 
        "open write unit 10 card name \"%s.psf\"\n"
        "write psf  unit 10 card\n"
        "delete atom sele atom * * * end\n",
         cur_segname );

	FILE *crdFile = fopen( cur_filename, "w");
	printCRDHeader( crdFile, *cur_natoms );
	fprintf(crdFile, "%s", cur_segment );
	fclose(crdFile);

	if( *npairs == *npair_space )
	{
		*npair_space *= 2;

		*pairs = (crd_psf_pair *)realloc( *pairs, sizeof(crd_psf_pair) * *npair_space );
	}

	strcpy( (*pairs)[*npairs].CRDfileName, cur_filename );
	char psf_file[256];
	sprintf(psf_file, "%s.psf", cur_segname );
	strcpy( (*pairs)[*npairs].PSFfileName, psf_file ); 

	(*npairs)++;
	
	(*seg_cntr)++;		
		
	sprintf(cur_filename, "segment_%s%d.crd", out_in[x_leaflet], *seg_cntr );
	sprintf(cur_segname, "%s%d", out_in[x_leaflet], *seg_cntr ); 


	*cur_size = 0;
	*cur_natoms = 0;
	(cur_segment)[0] = '\0';
	*cur_atom = 1;
	*cur_res  = 1;
	*switched=0;
}

double mod_exp( double val )
{
	if( val > 0 )
		return 1 + val;
	else	
		return exp(val);	
}

	
int TestAdd( surface *theSurface, int l, int *lipid_start, int *lipid_stop, struct atom_rec *at, 
	double *shift, double *upper_cen, double *add_to,
	double alpha,
	double main_u_cen,
	double main_v_cen,
	double *use_r, double *source_r,
	double spot_u, double spot_v,
	int fout,
	double *rsurf,
	int leaflet,
	double strain,
	double *dx_uv,
	double *dy_uv,	
	double w_use,
	double w_rim,
	double *rimp,
	double *rimn,
	int x_leaflet,
	double *total_lipid_charge,
	int *cur_atom,
	int *cur_natoms,
	double **placed_atoms,
	int *nplaced,
	int *nplacedSpace,
	char *cur_segname,
	char **cur_segment,
	int *cur_size,
	int *cur_space,
	int *cur_res,

	caa_box *theBoxes, int nx, int ny, int nz,
	int **local_cycles,
	int *local_cycle_len,
	int local_ncycles,

	int *local_bonds,
	int *local_nbonds,
	int *local_bond_offsets,
	FILE *doubleBondIndexes
	)
{	
	int pres = at[lipid_start[l]].res;
	
	double wrap_to[3] = {0,0,0};

	double *coords = (double *)malloc( sizeof(double) * ( lipid_stop[l] - lipid_start[l]+1) * 3 );
	double *o_coords = (double *)malloc( sizeof(double) * ( lipid_stop[l] - lipid_start[l]+1) * 3 );
	
	double r_pt[3], r_nrm[3];
	theSurface->evaluateRNRM( fout, spot_u, spot_v, r_pt, r_nrm, rsurf );


	int toff = 0;
	for( int xa = lipid_start[l]; xa <= lipid_stop[l]; xa++, toff++ )
	{
		double dx = alpha*(at[xa].x-upper_cen[0]+shift[0]);
		double dy = alpha*(at[xa].y-upper_cen[1]+shift[1]);
	
		double use_r[3] = { dx, dy, at[xa].z };
		double eval[3];
	
		double transp_u = main_u_cen;
		double transp_v = main_v_cen;
		
	
		double m1_r[3] = { use_r[0] - source_r[0], use_r[1] - source_r[1], use_r[2] };
		double local_u = spot_u, local_v = spot_v;
		theSurface->simple_evaluate_at( eval, m1_r, fout, &local_u, &local_v, rsurf, leaflet, strain, dx_uv, dy_uv, w_use, w_rim, rimp, rimn );
	
		double tc[3] = { eval[0], eval[1], eval[2] };

		if( xa > lipid_start[l] )
		{
			double dr[3] = { tc[0] - wrap_to[0], tc[1] - wrap_to[1], tc[2] - wrap_to[2] };
			theSurface->wrapPBC( dr, rsurf+3*theSurface->nv );
	
			tc[0] = wrap_to[0] + dr[0];
			tc[1] = wrap_to[1] + dr[1];
			tc[2] = wrap_to[2] + dr[2];
		}
		else
		{
			wrap_to[0] = tc[0];
			wrap_to[1] = tc[1];
			wrap_to[2] = tc[2];
		}
	
		coords[3*toff+0] = tc[0];	
		coords[3*toff+1] = tc[1];	
		coords[3*toff+2] = tc[2];	
	}
	
	int clash = 0;
	int nclash_iters = 20;	

	memcpy( o_coords, coords,  sizeof(double) * ( lipid_stop[l] - lipid_start[l]+1) * 3 );
	
	double PBC_vec[3][3];
	for( int c1=0;c1<3;c1++)
	for( int c2=0;c2<3;c2++)
		PBC_vec[c1][c2] = theSurface->PBC_vec[c1][c2];

	for( int clash_iter = 0; clash_iter < nclash_iters; clash_iter++ )
	{
		memcpy( coords, o_coords,  sizeof(double) * ( lipid_stop[l] - lipid_start[l]+1) * 3 );

		double jmag = 1.5;
		double jiggle[3] = { 
			jmag * 2 * (rand()/(double)RAND_MAX-0.5),
			jmag * 2 * (rand()/(double)RAND_MAX-0.5),
			jmag * 2 * (rand()/(double)RAND_MAX-0.5) };

		double dphi = clash_iter * 2*M_PI / nclash_iters;
		
		rotateArbitrary( coords, r_nrm, r_pt, ( lipid_stop[l] - lipid_start[l]+1), dphi );

		for( int t = 0; t < ( lipid_stop[l] - lipid_start[l]+1); t++ )
		{
			coords[3*t+0] += jiggle[0];
			coords[3*t+1] += jiggle[1];
			coords[3*t+2] += jiggle[2];
		}
	
		clash = 0;


		// FIRST, check local rings against global bonds.	


		for( int c = 0; c < local_ncycles && !clash; c++ )
		{
			int relev = 1;
	
			for( int xc = 0; xc < local_cycle_len[c]; xc++ )
			{
				if( local_cycles[c][xc] < lipid_start[l] || local_cycles[c][xc] > lipid_stop[l] )
					relev = 0; 
			}
	
			if( relev )
			{
				double ring_com[3] = {0,0,0};

				for( int t = 0; t < local_cycle_len[c]; t++ )
				{
					int loff = local_cycles[c][t] - lipid_start[l];
					ring_com[0] += coords[3*loff+0];
					ring_com[1] += coords[3*loff+1];
					ring_com[2] += coords[3*loff+2];
				}

				ring_com[0] /= local_cycle_len[c];
				ring_com[1] /= local_cycle_len[c];
				ring_com[2] /= local_cycle_len[c];
						
				int bx = ring_com[0] * nx / PBC_vec[0][0];
				int by = ring_com[1] * ny / PBC_vec[1][1];
				int bz = ring_com[2] * nz / PBC_vec[2][2];
						
				for( int dx = -1; dx <= 1 && !clash; dx++ )
				for( int dy = -1; dy <= 1 && !clash; dy++ )
				for( int dz = -1; dz <= 1 && !clash; dz++ )
				{
					int n_b_x = bx + dx;
					int n_b_y = by + dy;
					int n_b_z = bz + dz;
				
					if( n_b_x >= nx ) n_b_x -= nx;
					if( n_b_x < 0 ) n_b_x += nx;
					if( n_b_y >= ny ) n_b_y -= ny;
					if( n_b_y < 0 ) n_b_y += ny;
					if( n_b_z >= nz ) n_b_z -= nz;
					if( n_b_z < 0 ) n_b_z += nz;
		
					int nb = n_b_x*ny*nz+n_b_y*nz+n_b_z;
		
					for( int px = 0; px < theBoxes[nb].np && !clash; px++ )
					{
						int p = theBoxes[nb].plist[px];

						double dr[3] = { 
							(*placed_atoms)[3*p+0] - ring_com[0], 
							(*placed_atoms)[3*p+1] - ring_com[1],
							(*placed_atoms)[3*p+2] - ring_com[2] };
		
						double shift[3] = {0,0,0};
						while( dr[0] + shift[0] < -PBC_vec[0][0]/2 ) shift[0] += PBC_vec[0][0]; 
						while( dr[1] + shift[1] < -PBC_vec[1][1]/2 ) shift[1] += PBC_vec[1][1]; 
						while( dr[2] + shift[2] < -PBC_vec[2][2]/2 ) shift[2] += PBC_vec[2][2]; 
						while( dr[0] + shift[0] >  PBC_vec[0][0]/2 ) shift[0] -= PBC_vec[0][0]; 
						while( dr[1] + shift[1] >  PBC_vec[1][1]/2 ) shift[1] -= PBC_vec[1][1]; 
						while( dr[2] + shift[2] >  PBC_vec[2][2]/2 ) shift[2] -= PBC_vec[2][2];

						dr[0] += shift[0];
						dr[1] += shift[1];
						dr[2] += shift[2];
						double dist = normalize(dr);
		
						if( dist < 7.0 )
						{
							double convex_set[3*local_cycle_len[c]];
						
							for( int t = 0; t < local_cycle_len[c] && !clash; t++ )
							{
								int loff1 = local_cycles[c][t] - lipid_start[l];

								convex_set[3*t+0] = coords[loff1*3+0];
								convex_set[3*t+1] = coords[loff1*3+1];
								convex_set[3*t+2] = coords[loff1*3+2];
							}
								
							for( int bx = 0; bx < global_nbonds[p] && !clash; bx++ )
							{
								int p2 = global_bonds[global_bond_offsets[p]+bx];

								double r1[3] = { (*placed_atoms)[3*p+0], (*placed_atoms)[3*p+1],(*placed_atoms)[3*p+2]};
								double r2[3] = { (*placed_atoms)[3*p2+0], (*placed_atoms)[3*p2+1],(*placed_atoms)[3*p2+2]};

								r1[0] += shift[0];
								r1[1] += shift[1];
								r1[2] += shift[2];
								
								r2[0] += shift[0];
								r2[1] += shift[1];
								r2[2] += shift[2];
	
								if( box_GJK( convex_set, local_cycle_len[c], r1, r2, 0.75 ) )
									clash = 1;
							}
#if 0
							for( int t = 0; t < local_cycle_len[c] && !clash; t++ )
							{
							 	int tp1 = t+1;
								if( tp1 >= local_cycle_len[c] ) tp1 -= local_cycle_len[c];	
								int loff1 = local_cycles[c][t] - lipid_start[l];
								int loff2 = local_cycles[c][tp1] - lipid_start[l];
			
								double triangle[9] = 
								{
									coords[loff1*3+0],
									coords[loff1*3+1],
									coords[loff1*3+2],
									coords[loff2*3+0],
									coords[loff2*3+1],
									coords[loff2*3+2],
									ring_com[0],
									ring_com[1],
									ring_com[2],
								};

								for( int bx = 0; bx < global_nbonds[p] && !clash; bx++ )
								{
									int p2 = global_bonds[global_bond_offsets[p]+bx];

									double r1[3] = { (*placed_atoms)[3*p+0], (*placed_atoms)[3*p+1],(*placed_atoms)[3*p+2]};
									double r2[3] = { (*placed_atoms)[3*p2+0], (*placed_atoms)[3*p2+1],(*placed_atoms)[3*p2+2]};

									r1[0] += shift[0];
									r1[1] += shift[1];
									r1[2] += shift[2];
									
									r2[0] += shift[0];
									r2[1] += shift[1];
									r2[2] += shift[2];
	
									if( line_segment_triangle_intersection( r1,r2, triangle+0, triangle+3, triangle +6, 0.25) )
										clash = 1;
								} 
							}
#endif
						}
					}
				}
			}	
		}
		
		// SECOND: check global rings against local bonds.
		// can ring box this if it makes sense.	

		if( ! clash )
		{
			for( int c = 0; c < global_ncycles && !clash; c++ )
			{
				double ring_com[3] = {0,0,0};
	
				for( int t = 0; t < global_cycle_len[c]; t++ )
				{
					int loff = global_cycles[c][t];
					ring_com[0] += (*placed_atoms)[3*loff+0];
					ring_com[1] += (*placed_atoms)[3*loff+1];
					ring_com[2] += (*placed_atoms)[3*loff+2];
				}
	
				ring_com[0] /= global_cycle_len[c];
				ring_com[1] /= global_cycle_len[c];
				ring_com[2] /= global_cycle_len[c];

		
				for( int xa = lipid_start[l]; xa <= lipid_stop[l] && !clash; xa++, toff++ )
				{
					int loff = xa - lipid_start[l];
					double dr[3] = { 
						coords[3*loff+0] - ring_com[0], 
						coords[3*loff+1] - ring_com[1],
						coords[3*loff+2] - ring_com[2] };
			
					double shift[3] = {0,0,0};
					while( dr[0] + shift[0] < -PBC_vec[0][0]/2 ) shift[0] += PBC_vec[0][0]; 
					while( dr[1] + shift[1] < -PBC_vec[1][1]/2 ) shift[1] += PBC_vec[1][1]; 
					while( dr[2] + shift[2] < -PBC_vec[2][2]/2 ) shift[2] += PBC_vec[2][2]; 
					while( dr[0] + shift[0] >  PBC_vec[0][0]/2 ) shift[0] -= PBC_vec[0][0]; 
					while( dr[1] + shift[1] >  PBC_vec[1][1]/2 ) shift[1] -= PBC_vec[1][1]; 
					while( dr[2] + shift[2] >  PBC_vec[2][2]/2 ) shift[2] -= PBC_vec[2][2];
	
					dr[0] += shift[0];
					dr[1] += shift[1];
					dr[2] += shift[2];

					double r = normalize(dr);
	
					if( r < 7.0 )
					{
						for( int bx = 0; bx < local_nbonds[xa] && !clash; bx++ )
						{
							int loff2 = local_bonds[local_bond_offsets[xa]+bx] - lipid_start[l];
			
							double r1[3] = { 
								coords[3*loff+0] + shift[0],
								coords[3*loff+1] + shift[1],
								coords[3*loff+2] + shift[2] };
							double r2[3] = { 
								coords[3*loff2+0] + shift[0],
								coords[3*loff2+1] + shift[1],
								coords[3*loff2+2] + shift[2] };
							
							double convex_set[3*global_cycle_len[c]];
						
							for( int t = 0; t < global_cycle_len[c] && !clash; t++ )
							{
								int loff1 = global_cycles[c][t];
								convex_set[3*t+0] = (*placed_atoms)[loff1*3+0];
								convex_set[3*t+1] = (*placed_atoms)[loff1*3+1];
								convex_set[3*t+2] = (*placed_atoms)[loff1*3+2];
							}
	
							if( box_GJK( convex_set, global_cycle_len[c], r1, r2, 0.75 ) )
								clash = 2;
	/*
							for( int t = 0; t < global_cycle_len[c] && !clash; t++ )
							{
							 	int tp1 = t+1;
								if( tp1 >= global_cycle_len[c] ) tp1 -= global_cycle_len[c];	
								int loff1 = global_cycles[c][t];
								int loff2 = global_cycles[c][tp1];
					
								double triangle[9] = 
								{
									(*placed_atoms)[loff1*3+0],
									(*placed_atoms)[loff1*3+1],
									(*placed_atoms)[loff1*3+2],
									(*placed_atoms)[loff2*3+0],
									(*placed_atoms)[loff2*3+1],
									(*placed_atoms)[loff2*3+2],
									ring_com[0],
									ring_com[1],
									ring_com[2],
								};
								
								if( c == 1558 && xa == 623 && bx == 3 && t == 4 )
								{
									printf("Debug 2.\n");
								}
		

								if( line_segment_triangle_intersection( r1,r2, triangle+0, triangle+3, triangle +6, 0.25) )
									clash = 2;
							}*/
						}		
					}	
				}
			}
		}

		if( !clash ) 
		{
#ifdef DEBUG_PRINT
			if( clash_iter > 0 )
				printf("Clashed but resolved on iteration %d (%d).\n", clash_iter, clash );
#endif
			break;
		}
	}	

	if( clash ) 
	{
#ifdef DEBUG_PRINT
		printf("Unresolved clash (%d).\n", clash);
#endif
		return 0;
	}
	// passes:

	int placed_off = *nplaced;

	toff = 0;	
	for( int xa = lipid_start[l]; xa <= lipid_stop[l]; xa++, toff++ )
	{
		if( at[xa].res != pres )
			(*cur_res)++; 
		pres = at[xa].res;

		int at_save = at[xa].bead;
		int res_save = at[xa].res;
		double xsave = at[xa].x;
		double ysave = at[xa].y;
		double zsave = at[xa].z;

		at[xa].x = coords[3*toff+0];
		at[xa].y = coords[3*toff+1];
		at[xa].z = coords[3*toff+2];
	
		at[xa].bead = *cur_atom;
		at[xa].res  = *cur_res;
		at[xa].segRes = *cur_res;

		char temp_segid[256];
		sprintf(temp_segid, "MEMB");
		char *tmp = at[xa].segid;
		at[xa].segid = cur_segname;
	
		if( *cur_size + 1024 > *cur_space )
		{	
			*cur_space += 1024;
			(*cur_segment) = (char *)realloc( (*cur_segment), sizeof(char) * (*cur_space)  );
		}

		printSingleCRD( *cur_segment+*cur_size, at+xa );

		double rxy = sqrt(at[xa].x*at[xa].x+at[xa].y*at[xa].y);
		
		(*cur_size) += strlen(*cur_segment+*cur_size);

		if( (*nplaced) == (*nplacedSpace) )
		{
			(*nplacedSpace) *= 2;
			*placed_atoms = (double *)realloc( *placed_atoms, sizeof(double)*3* (*nplacedSpace) );
		}

		(*placed_atoms)[3*(*nplaced)+0] = at[xa].x;
		(*placed_atoms)[3*(*nplaced)+1] = at[xa].y;
		(*placed_atoms)[3*(*nplaced)+2] = at[xa].z;
		
		boxit( *placed_atoms+3*(*nplaced), *nplaced, theBoxes, theSurface->PBC_vec, nx, ny, nz );

		(*cur_natoms)++;
		at[xa].segid = tmp;
		at[xa].bead = at_save;
		at[xa].res = res_save;
	
		at[xa].x = xsave;
		at[xa].y = ysave;
		at[xa].z = zsave;
	
		(*cur_atom)++;
		total_lipid_charge[x_leaflet] += at[xa].charge;	

		int bond_warning = 0;

		if( local_bonds )
		{		/// add all the bonds to the global list. what a pain in the tush.
			if( global_bonds_tot + local_nbonds[xa] >= global_bond_space  )
			{
				if( global_bond_space == 0 )
				{
					global_bond_space = local_nbonds[xa] + global_bonds_tot;
					global_bonds = (int *)malloc( sizeof(int) * global_bond_space );
				}
				else
				{
					global_bond_space *= 2;
					global_bond_space += local_nbonds[xa];
					global_bonds = (int *)realloc( global_bonds, sizeof(int) * global_bond_space );
				}
			}

			if( *nplaced >= global_atom_space )
			{
				if( global_atom_space == 0 )
				{
					global_atom_space = *nplaced + 1;

					global_bond_offsets = (int *)malloc( sizeof(int) * global_atom_space );
					global_nbonds = (int *)malloc( sizeof(int) * global_atom_space );
				}
				else
				{
					global_atom_space *= 2;
				
					global_bond_offsets = (int *)realloc( global_bond_offsets, sizeof(int) * global_atom_space );
					global_nbonds = (int *)realloc( global_nbonds, sizeof(int) * global_atom_space );
				}
			}

			// is there space for the bond?
			global_nbonds[*nplaced] = local_nbonds[xa];
			int cur_off = 0;
			if( *nplaced > 0 )
				cur_off = global_bond_offsets[*nplaced-1] + global_nbonds[*nplaced-1];
			global_bond_offsets[*nplaced] = cur_off;
			
			for( int t = 0; t < local_nbonds[xa]; t++ )
			{
				global_bonds[global_bond_offsets[*nplaced]+t] = local_bonds[local_bond_offsets[xa]+t] + placed_off - lipid_start[l];	

				if( local_bonds[local_bond_offsets[xa]+t] < lipid_start[l] || local_bonds[local_bond_offsets[xa]+t] > lipid_stop[l] )
				{
					bond_warning = 1;
				}
				else
					global_bonds_tot += 1;
			}
		}
		
		if( bond_warning )
		{
			printf("WARNING: a bond in a lipid (%s:%d) extends outside of the lipid.\n", at[lipid_start[l]].resname, at[lipid_start[l]].res );
			printf("         This bond won't be checked for ring/bond penetration.\n");
		}
		(*nplaced)++;
	}


	for( int c = 0; c < local_ncycles; c++ )
	{
		int relev = 1;

		for( int xc = 0; xc < local_cycle_len[c]; xc++ )
		{
			if( local_cycles[c][xc] < lipid_start[l] || local_cycles[c][xc] > lipid_stop[l] )
				relev = 0; 
		}

		if( relev )
		{
			if( global_nspace == global_ncycles )
			{	
				if( global_nspace == 0  )
				{
					global_nspace = global_ncycles + 10;
					global_cycles = (int **)malloc( sizeof(int*) * global_nspace );	
					global_cycle_len = (int *)malloc( sizeof(int) * global_nspace ); 
				}
				else
				{
					global_nspace *= 2;
					global_cycles = (int **)realloc( global_cycles, sizeof(int *) * global_nspace ); 
					global_cycle_len = (int *)realloc( global_cycle_len, sizeof(int) * global_nspace ); 
				}
			}

			global_cycles[global_ncycles] = (int *)malloc( sizeof(int) * local_cycle_len[c] );
			global_cycle_len[global_ncycles] = local_cycle_len[c];

			for( int t = 0; t < local_cycle_len[c]; t++ )
				global_cycles[global_ncycles][t] = local_cycles[c][t] + placed_off - lipid_start[l]; 

			global_ncycles++;
		}
	}

	// add crossed bonds as cycles.
	// if three bonds cross, and it happens, it can be unbreakable.
	// loop over the atoms we added
	for( int xl = placed_off; xl < placed_off + lipid_stop[l] - lipid_start[l] +1; xl++ )
	{	
		int bx = (*placed_atoms)[3*xl+0] * nx / PBC_vec[0][0];
		int by = (*placed_atoms)[3*xl+1] * ny / PBC_vec[1][1];
		int bz = (*placed_atoms)[3*xl+2] * nz / PBC_vec[2][2];
				
		double r1A[3] = { (*placed_atoms)[3*xl+0], (*placed_atoms)[3*xl+1],(*placed_atoms)[3*xl+2]};
				
		// loop over nearby boxes
		for( int dx = -1; dx <= 1 ; dx++ )
		for( int dy = -1; dy <= 1 ; dy++ )
		for( int dz = -1; dz <= 1 ; dz++ )
		{
			int n_b_x = bx + dx;
			int n_b_y = by + dy;
			int n_b_z = bz + dz;
		
			if( n_b_x >= nx ) n_b_x -= nx;
			if( n_b_x < 0 ) n_b_x += nx;
			if( n_b_y >= ny ) n_b_y -= ny;
			if( n_b_y < 0 ) n_b_y += ny;
			if( n_b_z >= nz ) n_b_z -= nz;
			if( n_b_z < 0 ) n_b_z += nz;
		
			int nb = n_b_x*ny*nz+n_b_y*nz+n_b_z;
			// loop over the atoms in the box.	
			for( int px = 0; px < theBoxes[nb].np && !clash; px++ )
			{
				int p = theBoxes[nb].plist[px];

				// ignore atoms of our own molecule: intramolecular bonds should all be fine on input.
				if( p >= placed_off ) continue;
	
				double dr[3] = { 
					(*placed_atoms)[3*p+0] - r1A[0], 
					(*placed_atoms)[3*p+1] - r1A[1],
					(*placed_atoms)[3*p+2] - r1A[2] };
		
				double shift[3] = {0,0,0};
				while( dr[0] + shift[0] < -PBC_vec[0][0]/2 ) shift[0] += PBC_vec[0][0]; 
				while( dr[1] + shift[1] < -PBC_vec[1][1]/2 ) shift[1] += PBC_vec[1][1]; 
				while( dr[2] + shift[2] < -PBC_vec[2][2]/2 ) shift[2] += PBC_vec[2][2]; 
				while( dr[0] + shift[0] >  PBC_vec[0][0]/2 ) shift[0] -= PBC_vec[0][0]; 
				while( dr[1] + shift[1] >  PBC_vec[1][1]/2 ) shift[1] -= PBC_vec[1][1]; 
				while( dr[2] + shift[2] >  PBC_vec[2][2]/2 ) shift[2] -= PBC_vec[2][2];
	
				dr[0] += shift[0];
				dr[1] += shift[1];
				dr[2] += shift[2];
				double dist = normalize(dr);
		
			
				// if atom is close enough it's worth checking closely.
				if( dist < 7.0 )
				{
					double r2A[3] = { (*placed_atoms)[p*3+0], (*placed_atoms)[p*3+1], (*placed_atoms)[p*3+2] };

					r2A[0] += shift[0];
					r2A[1] += shift[1];
					r2A[2] += shift[2];

					for( int bx = 0; bx < global_nbonds[xl]; bx++ )
					for( int px = 0; px < global_nbonds[p]; px++ )
					{
						int b2 = global_bonds[global_bond_offsets[xl]+bx];
						int p2 = global_bonds[global_bond_offsets[p]+px];

						if( b2 < xl || p2 < p )
							continue;
	
						// no shift for r1B since it's in r1A's molecule.
						double r1B[3] = { (*placed_atoms)[3*b2+0], (*placed_atoms)[3*b2+1],(*placed_atoms)[3*b2+2]};
						double r2B[3] = { (*placed_atoms)[3*p2+0], (*placed_atoms)[3*p2+1],(*placed_atoms)[3*p2+2]};
	
						// PBC shift determined from first atom of other molecule.
						r2B[0] += shift[0];
						r2B[1] += shift[1];
						r2B[2] += shift[2];
			
						double t1, t2;
						double dr = segmentSegmentDist( r1A, r1B, r2A, r2B, &t1, &t2 );
		
						if( dr < 1.0 && t1 > -0.2 && t1 < 1.2 && t2 > -0.2 && t2 < 1.2 )
						{
							// add a cycle		
							if( global_nspace == global_ncycles )
							{	
								if( global_nspace == 0  )
								{
									global_nspace = global_ncycles + 10;
									global_cycles = (int **)malloc( sizeof(int*) * global_nspace );	
									global_cycle_len = (int *)malloc( sizeof(int) * global_nspace ); 
								}
								else
								{
									global_nspace *= 2;
									global_cycles = (int **)realloc( global_cycles, sizeof(int *) * global_nspace ); 
									global_cycle_len = (int *)realloc( global_cycle_len, sizeof(int) * global_nspace ); 
								}
							}
				
							global_cycles[global_ncycles] = (int *)malloc( sizeof(int) * 4 );
							global_cycle_len[global_ncycles] = 4;
				
							global_cycles[global_ncycles][0] = xl; 
							global_cycles[global_ncycles][1] = p; 
							global_cycles[global_ncycles][2] = b2; 
							global_cycles[global_ncycles][3] = p2; 
			
#ifdef DEBUG_PRINT	
							printf("Added a bond crossing cycle: r1: %lf %lf %lf r1B: %lf %lf %lf r2: %lf %lf %lf r2B: %lf %lf %lf t1: %lf t2: %lf dr: %lf\n",
							r1A[0],r1A[1],r1A[2],
							r1B[0],r1B[1],r1B[2],
							r2A[0],r2A[1],r2A[2],
							r2B[0],r2B[1],r2B[2], t1, t2, dr );
#endif						
							global_ncycles++;
						}
					}
				}
			}
		}
	}

	// add likely cis-double bonds to index file

	for( int xl = placed_off; xl < placed_off + lipid_stop[l] - lipid_start[l] +1; xl++ )
	{
		int loff1 = lipid_start[l] + xl - placed_off;
		if( at[loff1].atname[0] != 'C' ) continue;

		if( global_nbonds[xl] != 3 ) continue;

		int has_h = 0;

		for( int bx = 0; bx < global_nbonds[xl]; bx++ )
		{
			int b2 = global_bonds[global_bond_offsets[xl]+bx];
			int loff2 = lipid_start[l] + b2 - placed_off;
			if( at[loff2].atname[0] == 'H' ) {has_h=1;}
		}
		if( !has_h ) continue;
		for( int bx = 0; bx < global_nbonds[xl]; bx++ )
		{
			int b2 = global_bonds[global_bond_offsets[xl]+bx];
			int loff2 = lipid_start[l] + b2 - placed_off;
			if( at[loff2].atname[0] != 'C' ) continue;

			if( global_nbonds[b2] != 3 ) continue;
		
			has_h = 0;

			for( int by2 = 0; by2 < global_nbonds[b2]; by2++ )
			{
				int b4 = global_bonds[global_bond_offsets[b2]+by2];
				if( b4 == xl ) continue;
				int loff4 = lipid_start[l] + b4 - placed_off;
				if( at[loff4].atname[0] == 'H' ) has_h = 1;
			}

			if( !has_h ) continue;

			for( int bx2 = 0; bx2 < global_nbonds[xl]; bx2++ )
			{
				int b3 = global_bonds[global_bond_offsets[xl]+bx2];

				if( b3 == b2 ) continue;
				int loff3 = lipid_start[l] + b3 - placed_off;
				if( at[loff3].atname[0] != 'C' ) continue;
			
				for( int by2 = 0; by2 < global_nbonds[b2]; by2++ )
				{
					int b4 = global_bonds[global_bond_offsets[b2]+by2];
					if( b4 == xl ) continue;
					int loff4 = lipid_start[l] + b4 - placed_off;
					if( at[loff4].atname[0] != 'C' ) continue;

					double r4[12] =
					{
						(*placed_atoms)[3*b3+0], (*placed_atoms)[3*b3+1], (*placed_atoms)[3*b3+2],
						(*placed_atoms)[3*xl+0], (*placed_atoms)[3*xl+1], (*placed_atoms)[3*xl+2],
						(*placed_atoms)[3*b2+0], (*placed_atoms)[3*b2+1], (*placed_atoms)[3*b2+2],
						(*placed_atoms)[3*b4+0], (*placed_atoms)[3*b4+1], (*placed_atoms)[3*b4+2],
					};

//					double phi = (180/M_PI)*dihe(r4+0,r4+3,r4+6,r4+9);

//					if( fabs(phi) < 60.0 )
					{
						fprintf(doubleBondIndexes, "DIHEDRAL %d %d %d %d 500 0.0\n", b3, xl, b2, b4 );	
					}
				}
			}
			
		}
	}	

	return 1;
}
						
int TestAddRim( surface *theSurface, int l, int *lipid_start, int *lipid_stop, struct atom_rec *at, 
	double dx, double dy,
	double *lipid_xyz,
	double *shift, double *upper_cen, double *rim_center,
	double alpha,
	double *use_r,
	double *rsurf,
	int leaflet,
	int x_leaflet,
	double *total_lipid_charge,
	int *cur_atom,
	int *cur_natoms,
	double **placed_atoms,
	int *nplaced,
	int *nplacedSpace,
	char *cur_segname,
	char **cur_segment,
	int *cur_size,
	int *cur_space,
	int *cur_res,
	
	caa_box *theBoxes, int nx, int ny, int nz,

	int **local_cycles,
	int *local_cycle_len,
	int local_ncycles,

	int *local_bonds,
	int *local_nbonds,
	int *local_bond_offsets
	)
{
	int pres = at[lipid_start[l]].res;
	double wrap_to[3] = {0,0,0};
	for( int xa = lipid_start[l]; xa <= lipid_stop[l]; xa++ )
	{
		if( at[xa].res != pres )
			(*cur_res)++; 
		pres = at[xa].res;
	
		double xsave = at[xa].x;
		double ysave = at[xa].y;
		double zsave = at[xa].z;
		int at_save = at[xa].bead;
		int res_save = at[xa].res;
	
		double use_r[3] = { dx, dy, zsave };
	
		at[xa].x = dx + xsave - lipid_xyz[3*l+0];
		at[xa].y = dy + ysave - lipid_xyz[3*l+1];
	
		at[xa].x += rim_center[0];
		at[xa].y += rim_center[1];
		at[xa].z += rim_center[2];

		if( xa > lipid_start[l] )
		{
			double dr[3] = { at[xa].x - wrap_to[0], at[xa].y - wrap_to[1], at[xa].z - wrap_to[2] };
			theSurface->wrapPBC( dr, rsurf+3*theSurface->nv );
	
			at[xa].x = wrap_to[0] + dr[0];
			at[xa].y = wrap_to[1] + dr[1];
			at[xa].z = wrap_to[2] + dr[2];
		}
		else
		{
			wrap_to[0] = at[xa].x;
			wrap_to[1] = at[xa].y;
			wrap_to[2] = at[xa].z;
		}
	
		at[xa].bead = *cur_atom;
		at[xa].res  = *cur_res;
		at[xa].segRes = *cur_res;

		char temp_segid[256];
		sprintf(temp_segid, "MEMB");
		char *tmp = at[xa].segid;
		at[xa].segid = cur_segname;
	
		if( *cur_size + 1024 > *cur_space )
		{	
			*cur_space += 1024;
			(*cur_segment) = (char *)realloc( (*cur_segment), sizeof(char) * (*cur_space)  );
		}

		printSingleCRD( *cur_segment+*cur_size, at+xa );

		double rxy = sqrt(at[xa].x*at[xa].x+at[xa].y*at[xa].y);
		
		(*cur_size) += strlen(*cur_segment+*cur_size);

		if( (*nplaced) == (*nplacedSpace) )
		{
			(*nplacedSpace) *= 2;
			*placed_atoms = (double *)realloc( *placed_atoms, sizeof(double)*3* (*nplacedSpace) );
		}

		(*placed_atoms)[3*(*nplaced)+0] = at[xa].x;
		(*placed_atoms)[3*(*nplaced)+1] = at[xa].y;
		(*placed_atoms)[3*(*nplaced)+2] = at[xa].z;
		(*nplaced)++;
			
		boxit( *placed_atoms+3*(*nplaced), *nplaced, theBoxes, theSurface->PBC_vec, nx, ny, nz );

		(*cur_natoms)++;
		at[xa].segid = tmp;
		at[xa].bead = at_save;
		at[xa].res = res_save;
	
		at[xa].x = xsave;
		at[xa].y = ysave;
		at[xa].z = zsave;
	
		(*cur_atom)++;
		total_lipid_charge[x_leaflet] += at[xa].charge;
	}

	return 1;
}
	
void boxit( double *r_in, int index, caa_box *theBoxes, double PBC_vec[3][3], int nx, int ny, int nz ) 
{ 
	double r[3] = { r_in[0], r_in[1], r_in[2] };
	
	while( r[0] <  0 ) r[0] += PBC_vec[0][0];
	while( r[1] <  0 ) r[1] += PBC_vec[1][1];
	while( r[2] <  0 ) r[2] += PBC_vec[2][2];
	while( r[0] >  PBC_vec[0][0] ) r[0] -= PBC_vec[0][0];
	while( r[1] >  PBC_vec[1][1] ) r[1] -= PBC_vec[1][1];
	while( r[2] >  PBC_vec[2][2] ) r[2] -= PBC_vec[2][2];

	int bx = r[0] * nx / PBC_vec[0][0];
	int by = r[1] * ny / PBC_vec[1][1];
	int bz = r[2] * nz / PBC_vec[2][2];

	if( bx >= nx ) bx -= nx;
	if( bx < 0 ) bx += nx;
	if( by >= ny ) by -= ny;
	if( by < 0 ) by += ny;
	if( bz >= nz ) bz -= nz;
	if( bz < 0 ) bz += nz;

	int b = bx*ny*nz+by*nz+bz;

	if( theBoxes[b].np == theBoxes[b].npSpace )
	{
		theBoxes[b].npSpace *= 2;
		theBoxes[b].plist = (int * )realloc( theBoxes[b].plist, sizeof(int) * theBoxes[b].npSpace );
	}

	theBoxes[b].plist[theBoxes[b].np] = index;
	theBoxes[b].np += 1;
}
